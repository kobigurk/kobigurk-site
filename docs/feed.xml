<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-10-31T00:47:52+03:00</updated><id>/feed.xml</id><entry><title type="html">Random Oracles in Cryptography</title><link href="/2021/10/31/random-oracles.html" rel="alternate" type="text/html" title="Random Oracles in Cryptography" /><published>2021-10-31T00:00:00+03:00</published><updated>2021-10-31T00:00:00+03:00</updated><id>/2021/10/31/random-oracles</id><content type="html" xml:base="/2021/10/31/random-oracles.html">&lt;p&gt;This article describes the role and sources of randomness in cryptographic protocols&lt;/p&gt;

&lt;p&gt;The post is co-authored with &lt;a href=&quot;https://twitter.com/tomwaltonpocock&quot; target=&quot;_blank&quot;&gt;Tom&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;

&lt;p&gt;Randomness is ubiquitous across the cryptography underpinning blockchain infrastructures — in the Merkle trees securing state, in the random-selection mechanism in proof of work, in the selection of committees in proof of stake, and in the zero knowledge proofs underpinning both scaling and privacy.&lt;/p&gt;

&lt;p&gt;Hash functions are the most important source of randomness in these protocols.&lt;/p&gt;

&lt;h1 id=&quot;whats-a-hash-function&quot;&gt;What’s a Hash Function?&lt;/h1&gt;

&lt;p&gt;A hash function takes in a ‘message’ (this could be any data — the state of a blockchain, the contents of a transaction, etc) and ‘spits out’ a digest of a fixed length, in some predefined ‘space’ of numbers. This could be all numbers up to \(2^{256}\), or it could be elements of a prime field (common in zero knowledge proofs), or even sometimes elliptic curve points, which are numbers of a different kind.&lt;/p&gt;

&lt;p&gt;The point is, the ‘magnitude’ of the output given the input should be completely unpredictable, until the hash is actually computed.&lt;/p&gt;

&lt;p&gt;Hashes are typically seen in two settings:&lt;/p&gt;

&lt;p&gt;As a short  ‘unique fingerprint’ on data (typically the ‘state’ of the blockchain, or the contents of a transaction), and&lt;/p&gt;

&lt;p&gt;A way of replacing questions that should be supplied by the verifier in certain ‘interactive protocols’. This is a common feature of zero knowledge proofs. The security of interactive protocols depends on a sequence of questions and answers between the ‘verifier’ and the ‘prover’. Hashes can be used to remove the need for a direct back-and-forth dialogue between the prover (usually the spender of money) and the verifier (the blockchain nodes checking all transactions are correct)&lt;/p&gt;

&lt;h1 id=&quot;property-1-for-hashes-randomness&quot;&gt;Property #1 for Hashes: Randomness&lt;/h1&gt;

&lt;p&gt;A core property of hash functions is therefore they scramble input data in a seemingly random fashion. When new hash functions are proposed, they must be subjected to rigorous statistical tests to satisfy the cryptography community that they do indeed exhibit their claimed randomness. Any failure to do so would produce features that expose protocols relying on them to potential attack.&lt;/p&gt;

&lt;p&gt;This randomness is useful in many contexts.&lt;/p&gt;

&lt;p&gt;Pseudorandom Function Families (PRFs) are functions that, similar to hash functions, map a message to an output, but additionally have a key as an input. PRFs can be built from these random-looking hashes, and, for example, can be used to build message authentication codes, to protect message authenticity and integrity. These hashes can also help when converting interactive proofs to non-interactive. If during the interactive proof a verifier sends uniformly random elements to the prover as challenges, the Fiat-Shamir heuristic can use a hash to replace the interactive random challenge with a hash of the proving process messages so far, as this should produce a sufficient random element for this purpose.&lt;/p&gt;

&lt;h1 id=&quot;property-2-for-hashes-collision-resistance&quot;&gt;Property #2 for Hashes: Collision Resistance&lt;/h1&gt;

&lt;p&gt;Additionally, we want it to be the following:&lt;/p&gt;

&lt;p&gt;Collision-resistant - hard to find two different messages that produce the same result&lt;/p&gt;

&lt;p&gt;Pre-image resistant - given an output, hard to find an input that produces it&lt;/p&gt;

&lt;p&gt;Second pre-image resistant - given an input and output, hard to find another input that produces the same output&lt;/p&gt;

&lt;p&gt;The desire for collision-resistance is direct - if we digest two different messages into the same hash, we can’t distinguish them anymore. Therefore, we want the short hash digest to be as unique as possible for different messages, in the sense that we can’t maliciously craft messages that have the same hash.  As a rule of thumb, collision resistance is usually easier to attack than pre-image resistance. This is because in collision resistance you have the freedom to choose any two inputs, where in both variants of pre-image resistance you are restricted to a specific output. Birthday attacks immediately reduce the complexity of finding a collision to a square root of the amount of possible outputs. Generally, when a collision is found, it’s a strong signal hash function should be phased out, as it signals worse attacks may happen.&lt;/p&gt;

&lt;p&gt;Another common place where it appears is some signature schemes: in Schnorr signatures we require a “hash to field” and in BLS signatures we require a “hash to group”. In both cases, this hash provides us with a unique element from the target set that is unrelated to other results of the hash. For example, we don’t want it to be the case that if you call the hash function \(H\) on \(m_1\) and \(m_2\), then you can also somehow deduce \(H(m_3)\).&lt;/p&gt;

&lt;h1 id=&quot;provable-security-and-the-standard-model&quot;&gt;Provable Security and the “Standard Model”&lt;/h1&gt;

&lt;p&gt;Hashes, then, sound super useful! What’s the problem?&lt;/p&gt;

&lt;p&gt;While useful for protocol designers, introducing hash functions to protocols makes life hard for cryptographers, when they approach proving security for the protocols. Cryptographers like to work with reductions - you formulate a security property for your protocol, and show that if that security property is broken by an adversary, then it implies that we also solved an unsolvable problem, an assumption.&lt;/p&gt;

&lt;p&gt;Proving security of protocols using computational hardness assumptions is considered working within the Standard Model. This means that you assume some problems are hard, and try to prove that your protocol’s security properties can be explained to be as hard as this problem. One such problem that is widely known is the Discrete Logarithm problem in a group: given \(g\) and \(h\), find \(x\) such that \(g^x = h\). If someone wants to break your protocol’s security properties, and you prove that in order to break it you would have to find a Discrete Logarithm, then you’re in a really good shape.&lt;/p&gt;

&lt;p&gt;A concrete example is the case of ElGamal encryption, where we have the IND-CPA property that roughly states that even if you know a ciphertexts is an encryption of one of a set of plaintexts you’ve chosen, you will not be able to know which of the plaintexts was chosen. The assumption that is solved if that property is broken is DDH - Decisional Diffie Hellman, that states that \((g^x, g^y, g^{xy})\) is indistinguishable from \((g^x, g^y, g^z)\), given random \(x,y,z\) and a group generator \(g\).&lt;/p&gt;

&lt;p&gt;Hashes throw a wrench into that and constrain the ability of cryptographers to make such reductions, and without an alternative modeling of the protocol, we would be left with “we’ve tried to break this protocol for some time and couldn’t”, which feels unsatisfactory.&lt;/p&gt;

&lt;h1 id=&quot;random-oracles-to-the-rescue&quot;&gt;Random Oracles to the Rescue&lt;/h1&gt;

&lt;p&gt;Random oracles can solve this.&lt;/p&gt;

&lt;p&gt;They provide a way to do a security-reduction proof, to gain confidence in the security of the protocol. When working within the Random Oracle Model, we replace each hash functions with an idealized Random Oracle:&lt;/p&gt;

&lt;p&gt;When a query is made on a new message, a random response from the target set is returned, chosen uniformly from it.&lt;/p&gt;

&lt;p&gt;When a query on a message that has been queried on before, the same response as before is returned.&lt;/p&gt;

&lt;h1 id=&quot;programmable-random-oracles&quot;&gt;“Programmable” Random Oracles&lt;/h1&gt;

&lt;p&gt;This introduces the concept of programmable random oracles, in which we allow some of the participants to program it — return values of its choosing, as long as they appear random to the receiver. It may sounds a bit weird, since the functions we would use in reality don’t have that feature. Given that it allows cryptographers provide positive results on the security of some protocols and that the consumer of oracle doesn’t see the difference, as they still see random values, it seems like a reasonable trade-off to make.&lt;/p&gt;

&lt;p&gt;Specifically, we can allow an adversary that wants to break an assumption, let’s say DDH, to simulate the environment of another adversary that claims they know to break a security property of the protocol.&lt;/p&gt;

&lt;p&gt;By programming the random oracle, we can use the responses from the adversary whose environment to then break the assumption.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/random-oracle.png&quot; alt=&quot;random-oracle&quot; style=&quot;width: 100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are a few other different variants, providing different levels of confidence - for example, non-programmable random oracles.&lt;/p&gt;

&lt;h1 id=&quot;its-not-all-roses&quot;&gt;It’s not all Roses&lt;/h1&gt;

&lt;p&gt;Alright, this sounds really powerful. What’s the catch? The catch is that random oracles don’t really exist. Good hashes only approximately behave like them.&lt;/p&gt;

&lt;p&gt;Take one of the most famous hashes — SHA-256. Try inputting a few numbers, SHA(1), SHA(2), etc. Run a few statistical tests to see in which ‘regions’ of the number grid \(2^{256}\) looks random.&lt;/p&gt;

&lt;p&gt;But true random functions don’t exist, almost by definition — a function is algorithmic, deterministic. Even worse, since random oracles don’t really exist, there are pathological examples where a scheme is proven to be secure in the random oracle model but is insecure when instantiated with any hash function.&lt;/p&gt;

&lt;p&gt;So is this at all useful? It gives a bit of confidence and it helps catching bad protocol design mistakes in other parts of the protocol. The intuition is that if your hash function behaves like a random oracle, then the proof somewhat applies to it. If it doesn’t, then the proof doesn’t even patter. It’s also sometimes the best we can get for some protocols, so it’s much better than nothing.&lt;/p&gt;

&lt;p&gt;You may also wonder - what are good instantiations of random oracles? When the source and target spaces are just sequences of bytes, they can more easily be built directly from known hash functions, like SHA256. When we’re talking about prime fields and elliptic curve groups it’s harder and there are many pitfalls on the way.&lt;/p&gt;

&lt;h1 id=&quot;whats-next&quot;&gt;What’s Next?&lt;/h1&gt;

&lt;p&gt;If you’re curious to see how programmable random oracles can be used to prove security for the famous BLS signature scheme, read the appendix!&lt;/p&gt;

&lt;p&gt;Lastly, if you want to try to break a protocol which uses a subtly bad instantiation of a random oracle, check out the first puzzle of zkhack :)&lt;/p&gt;

&lt;h1 id=&quot;appendix&quot;&gt;Appendix&lt;/h1&gt;

&lt;h2 id=&quot;bls-security-proof&quot;&gt;BLS security proof&lt;/h2&gt;

&lt;p&gt;Let’s look at a shortened version of a concrete example, BLS signatures (if you need some background on BLS signatures, I recommend reading this:&lt;/p&gt;

&lt;p&gt;Assumption - co-CDH: Given \(g_1^a \in \mathbb{G}_1\), \(g_2^a \in \mathbb{G}_2\) and \(h \in \mathbb{G}_2\), computing \(h^a \in \mathbb{G}_2\) is hard. We are given \(g,g^a,h\) as a challenge.&lt;/p&gt;

&lt;p&gt;Security property - Existential Unforgability, roughly stating that given a public key \(pk\), even if you see a bunch of signatures on different messages, you will not be able to forge a signature on another message without access to the secret key.&lt;/p&gt;

&lt;p&gt;Proof method sketch:&lt;/p&gt;

&lt;p&gt;We build an adversary \(A\) that breaks co-CDH.&lt;/p&gt;

&lt;p&gt;The adversary \(F\) who claims they break Existential Unforgability is given a public key \(pk=g^a \in \mathbb{G}_1\), the same one that is received in the challenge where both \(A\) and \(F\) don’t know \(a\), and makes a few random oracle queries while they’re still in the first phase of getting signatures on different messages. They also make signature queries. We know that they will make more random oracle queries than signature queries, since they have a phase where they request signatures, which implies both a random oracle query and a signaturequery , and a phase where they forge a signature, which means they query the random oracle but don’t request a signature.&lt;/p&gt;

&lt;p&gt;We guess beforehand an index of a message where \(F\) queries the random oracle but does not request a signature. This would also be the message for which \(F\) forges a signature.&lt;/p&gt;

&lt;p&gt;In those queries where both a random oracle is queries and a signature is requested, we have to provide answers that would pass the BLS verification check \(e(pk, H(m)) = e(g_1, \sigma)\) and also look random. We choose a random \(r\), and compute \(H(m) = g_2^r, \sigma = (g_2^a)^r\), Note that we can do that without knowing \(a\) and this still passes the verification check.&lt;/p&gt;

&lt;p&gt;In the query where \(F\) only queries the random oracle, we embed the rest of the challenge that we got: \(H(m) = g_2^r \cdot h\). Note that for this case we couldn’t compute \(\sigma\) if we were requested - since we don’t know the entire exponent, it’s not only \(r\) anymore. Also note that this still appears random since \(h^r\) appears random.&lt;/p&gt;

&lt;p&gt;Since \(F\) knows to forge a signature \(\sigma\) that satisfies \(e(pk,H(m)) = e(g_1, \sigma) \Rightarrow e(g_1^a, g_2^r \cdot h) = e(g_q, \sigma)\), we have that \(\sigma = (g_2^r \cdot h)^a\). Taking \(\frac{\sigma}{(g_2^a)^r}\), we get \(h^a\) as desired!&lt;/p&gt;

&lt;h2 id=&quot;broken-hash-to-curve&quot;&gt;Broken hash-to-curve&lt;/h2&gt;

&lt;p&gt;Recall that we’re looking for a hash that takes a mesage and gives a group element. One particular example I’ve seen in the wild which is broken is doing it in two steps: hash to field \(H(m)\) and then multiply by the generator \(g_2^{H(m)}\). This is broken since given a signature, being \(g_2^{H(m)x}\), where \(x\) is the secret key, we can transform it into a signature for \(m’\) without knowing \(x\), by doing \((g_2^{H(m)x})^{H(m)^{-1}H(m')} = g_2^{H(m')x}\).&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">This article describes the role and sources of randomness in cryptographic protocols</summary></entry><entry><title type="html">Cross platform Go modules for giants</title><link href="/2021/08/22/cross-platform-go-modules-for-giants.html" rel="alternate" type="text/html" title="Cross platform Go modules for giants" /><published>2021-08-22T00:00:00+03:00</published><updated>2021-08-22T00:00:00+03:00</updated><id>/2021/08/22/cross-platform-go-modules-for-giants</id><content type="html" xml:base="/2021/08/22/cross-platform-go-modules-for-giants.html">&lt;p&gt;When your Go modules become too large.&lt;/p&gt;

&lt;h1 id=&quot;tldr&quot;&gt;Tl;dr&lt;/h1&gt;

&lt;p&gt;What can you do when your Go module becomes too large for the Go tools to handle?!&lt;/p&gt;

&lt;p&gt;When you see this?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;module source tree too large (max size is 524288000 bytes)&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Go modules are a convenient to share code. You define a module with its version in go.mod and to Go tools automatically take care of downloading the right version, checking its integrity and compiling it.&lt;/p&gt;

&lt;p&gt;CGo enables integrating non-Go code by either allowing you to compile C code or just link to external libraries and call functions exported there through a convenient interface.&lt;/p&gt;

&lt;p&gt;Let’s say you have an externally compiled library that you want to distribute with your Go module but still use the usual Go tools. Adding a compilation step can’t happen, since that would require invoking, and perhaps installing, external tools, which the Go tools doesn’t support.&lt;/p&gt;

&lt;p&gt;The solution is to commit your library as part of the Go module codebase, which gets downloaded together with the rest of the source code.&lt;/p&gt;

&lt;p&gt;Now, let’s say you want to support multiple platforms. Fortunately, Go has built in capabilities to include source files based on the platform compiling, so we can:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Compile the library for each target platform&lt;/li&gt;
  &lt;li&gt;Create a platform-dependent source file that links to the right library&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This works reasonably well, with the caveat that the Go module the tools need to download becomes larger as a result.&lt;/p&gt;

&lt;p&gt;What happens when the library become too large? When it’s a static library that didn’t optimize for size and relied on consumers just taking what they need, which the Go tools do? This is what you see if your Go module is too large:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;module source tree too large (max size is 524288000 bytes)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Concretely, if you want to support Linux, macOS, Windows on x86_64, ARMv7, ARMv8 and s390x, where applicable, that becomes a big set of libraries that can exceed 500mb.&lt;/p&gt;

&lt;p&gt;Why is that important? Because the maximum module size Go supports is 500mb. This is intentional to prevent denial-of-service attacks, as mentioned in &lt;a href=&quot;https://golang.org/ref/mod#zip-path-size-constraints&quot;&gt;https://golang.org/ref/mod#zip-path-size-constraints&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Can we have still use the usual Go workflow and support that many platforms? The answer is yes!&lt;/p&gt;

&lt;p&gt;We first provide an overview of the workflow when the module size is less than 500mb, and then we’ll see how to make it work with the the giant libraries case. We’ll use as a study case the &lt;a href=&quot;https://github.com/celo-org/celo-bls-go&quot;&gt;celo-bls-go&lt;/a&gt; library, which is a Go module that links to an underlying Rust library.&lt;/p&gt;

&lt;h1 id=&quot;not-too-big&quot;&gt;Not too big&lt;/h1&gt;

&lt;p&gt;When your library is big, but not too big, you can employ a relatively simple structure. Assuming our Go package is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bls&lt;/code&gt;, we can employ the following structure:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Main code file, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bls.go&lt;/code&gt;, that contains the invocations of the different functions from the underlying library using CGo. This comes together with a header file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bls.h&lt;/code&gt; that describes the imported functions. For example:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func GeneratePrivateKey() (*PrivateKey, error) {
	privateKey := &amp;amp;PrivateKey{}
	success := C.generate_private_key(&amp;amp;privateKey.ptr)
	if !success {
		return nil, GeneralError
	}

	return privateKey, nil
}&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Per-platform file that only describes the linking directives, and has a build directive causing it to be compiled only if targeting this platform. For example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bls_darwin64.go&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;// +build darwin,amd64,!ios

package bls

/*
#cgo LDFLAGS: -L${SRCDIR}/../libs/x86_64-apple-darwin -lbls_snark_sys -ldl -lm
*/
import &quot;C&quot;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not too bad!&lt;/p&gt;

&lt;h1 id=&quot;is-it-all-doomed&quot;&gt;Is it all doomed?&lt;/h1&gt;

&lt;p&gt;The solution described in the previous section has worked for us for quite a while, until very recently when our underlying Rust library grew bigger and we wanted to support more platforms, such as the recent M1, 32-bit ARM and s390x.&lt;/p&gt;

&lt;p&gt;We realized that it’s a harder case quickly. Remember, our goal is to still be able to keep using the usual Go tools.&lt;/p&gt;

&lt;p&gt;Some solutions that we’ve tried and and failed or we rejected include:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Downloading the library on demand per-platform. Go didn’t seem to provide a way to do it.&lt;/li&gt;
  &lt;li&gt;See if there’s a way to remove the 500mb module size limit. We didn’t find a way with the usual Go tools, since it’s enforced on the client side.&lt;/li&gt;
  &lt;li&gt;Reducing the library size. It’s possible, but not a long-term or scalable solution.&lt;/li&gt;
  &lt;li&gt;Have users install the library through other means, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apt&lt;/code&gt;, like other common libraries like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openssl&lt;/code&gt;do. Possible, but significantly worse developer and user experience for our specific library.&lt;/li&gt;
  &lt;li&gt;Require developers who consumed the module go through a custom vendoring process. We didn’t even test this.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So… now what?&lt;/p&gt;

&lt;h1 id=&quot;big-friendly-giant&quot;&gt;Big friendly giant&lt;/h1&gt;

&lt;p&gt;Having realized it’s not going to be an officially-described method or something that is widely employed, we embarked on creating our own.&lt;/p&gt;

&lt;p&gt;Since our problem is with the library size when distributing all platforms, we first handled that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Distribute the per-platform libraries to packages, such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;celo-bls-go-linux&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;celo-bls-go-macos&lt;/code&gt;, etc&lt;/li&gt;
  &lt;li&gt;In each package, have a similar structure as described previously. Namely, a main source file and a per-platform source file that has the linking and build directives. This is only for the platforms supported in this package.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is still not seamless to consumers, since they would have to choose which &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;celo-bls-go-PACKAGE&lt;/code&gt; to choose, depending on their platform.&lt;/p&gt;

&lt;p&gt;We then introduce a main module, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;celo-bls-go&lt;/code&gt;, that has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;router&lt;/code&gt; per package called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bls_PACKAGE.go&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It has an appropriate build directive, which is the union of the build directives of the platforms included in the package.&lt;/li&gt;
  &lt;li&gt;It imports the correct package, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;celo-bls-go-PACKAGE&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;It has wrapper functions for all public functions, consts and vars in the package. For example:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;func HashDirectFirstStep(message []byte, hashBytes int32) ([]byte, error) {
    return blsRoute.HashDirectFirstStep(message, hashBytes)
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ease in creating this structure, that unfortunately includes a lot of similar code, we then introduced the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distribute&lt;/code&gt;program that consumes source templates, router templates and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;platforms.json&lt;/code&gt; and produces the per-package files. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;platforms.json&lt;/code&gt; file looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;{
	&quot;linux&quot;: [{
		&quot;name&quot;: &quot;linux_arm64&quot;,
		&quot;buildDirective&quot;: &quot;linux,arm64&quot;,
		&quot;linkageDirective&quot;: &quot;-L${SRCDIR}/../libs/aarch64-unknown-linux-gnu -lbls_snark_sys -ldl -lm&quot;,
		&quot;libDirectories&quot;: [&quot;aarch64-unknown-linux-gnu&quot;]
	}, ...
  ],
  &quot;macos&quot;: [{
		&quot;name&quot;: &quot;darwin64&quot;,
		&quot;buildDirective&quot;: &quot;darwin,amd64,!ios&quot;,
		&quot;linkageDirective&quot;: &quot;-L${SRCDIR}/../libs/x86_64-apple-darwin -lbls_snark_sys -ldl -lm&quot;,
		&quot;libDirectories&quot;: [&quot;x86_64-apple-darwin&quot;]
	}, ...
  ],
  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distribute.go&lt;/code&gt;can be viewed here: &lt;a href=&quot;https://github.com/celo-org/celo-bls-go/blob/c0f37c3a9a6cfb448a152f785391efd42f03f895/cmd/distribute/distribute.go&quot;&gt;https://github.com/celo-org/celo-bls-go/blob/c0f37c3a9a6cfb448a152f785391efd42f03f895/cmd/distribute/distribute.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is it!&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;The solution we described works reasonably well and achieves what we set out to achieve.&lt;/p&gt;

&lt;p&gt;I imagine there’s a bunch of ways it could improved. One example is that we could use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; package to automatically derive the router rather than manually writing it.&lt;/p&gt;

&lt;p&gt;I’d love to hear feedback and improvement suggestions!&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;Thanks to Michael and George for reviewing.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">When your Go modules become too large.</summary></entry><entry><title type="html">StarDrop - anonymous rewards on StarkNet</title><link href="/2021/07/14/stardrop.html" rel="alternate" type="text/html" title="StarDrop - anonymous rewards on StarkNet" /><published>2021-07-14T00:00:00+03:00</published><updated>2021-07-14T00:00:00+03:00</updated><id>/2021/07/14/stardrop</id><content type="html" xml:base="/2021/07/14/stardrop.html">&lt;p&gt;This post is about an experimental project to distribute rewards in a privacy-preserving manner running on StarkNet.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Blockchain projects seek to reward community members who perform activities that are beneficial to the network.&lt;/p&gt;

&lt;p&gt;For example, technical users participating in a test network for a project might get a few tokens in return for their participation. Another example includes users reteweeting a few tweets posted by the project.&lt;/p&gt;

&lt;p&gt;This brings up a privacy problem. In contrast to normal pseudonymous transactions, these rewards usually require some form of Know Your Customer procedure, even if it’s just a twitter handle. From this, it follows that the project awarding the tokens, or in some cases anyone, can track the user’s activity after receiving the reward.&lt;/p&gt;

&lt;p&gt;We can do better!&lt;/p&gt;

&lt;p&gt;StarDrop allows users in a group to claim a reward allocated to them, without the network or the project learning a link between the claims and the users. It uses techniques adapted from &lt;a href=&quot;https://privacypass.github.io/&quot; target=&quot;_blank&quot;&gt;Privacy Pass&lt;/a&gt; to build a Verifiable Oblivious Pseudo Random Function.&lt;/p&gt;

&lt;p&gt;The result is a system allowing a project to blindly sign a token that the user can use to redeem a reward later. Moreover, it does so in an on-chain zkrollup, StarkNet, allowing to do this verifiable in scale in low cost, as is appropriate for rewards that are usually not large.&lt;/p&gt;

&lt;p&gt;Disclaimer - I’ve created this project mostly to learn and experiment with StarkNet and it should not be used in production!&lt;/p&gt;

&lt;h1 id=&quot;privacy-pass&quot;&gt;Privacy Pass&lt;/h1&gt;

&lt;p&gt;Let’s first describe a sketch of a simplified version of Privacy Pass that we’ll use to build our protocol. In general, Privacy Pass is a 2-party protocol allowing a user to create a blinded token, that a server will sign after performing their checks, and the user afterwards unblinding the signed token and being able to use it without the server learning which token belonged to which user. For a more in-depth description, check out &lt;a href=&quot;https://kobi.one/2019/01/05/exploring-privacypass.html&quot; target=&quot;_blank&quot;&gt;my post about Privacy Pass&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A user generates a token \(t\), which is a string of their choice.&lt;/li&gt;
  &lt;li&gt;The user then hashes it to a curve \(H(t)\), resulting in an element of a specific elliptic curve.&lt;/li&gt;
  &lt;li&gt;The user chooses a random blinding factor \(b\) and computes \(T=bH(t)\).&lt;/li&gt;
  &lt;li&gt;The user then sends \(T\) to the server.&lt;/li&gt;
  &lt;li&gt;The server uses their private key \(s\), having public key \(P=sG\) where \(G\) is a known generator of the curve, and sign the token, resulting in \(S=sT\). The server provides a proof that \(S\) and \(T\) have the same ratio as \(P\) and \(G\), proving that \(S\) is a valid signed token.&lt;/li&gt;
  &lt;li&gt;The user verifiers the proof and then unblinds it using the inverse of their blinding factor, resulting in \(R=b^{-1}S=b^{-1}sT=b^{-1}sbH(t)=sH(t)\). Notice that this is still a signed token, just without the blinding factor.&lt;/li&gt;
  &lt;li&gt;The user can then use the signed token \(R\) to redeem their reward. They do it by sending \(t\) and \(R\) to the server.&lt;/li&gt;
  &lt;li&gt;The server then computes by itself \(sH(t)\), and checks if it equals to \(R\). If it does, it proves that the user possessed a signed token, as they could not have produced \(R\) from \(t\) by themselves.&lt;/li&gt;
  &lt;li&gt;If successful, the server saves \(t\) as have been redeemed, so it could not be redeemed again.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that the original Privacy Pass construction uses an HMAC here, but this detail is not important in our case.&lt;/p&gt;

&lt;h2 id=&quot;stardrops-adaptations&quot;&gt;StarDrop’s adaptations&lt;/h2&gt;

&lt;p&gt;In our case, we’d like to allow users to claim their rewards on-chain, and so there isn’t a server we would claim the rewards against. There is only a smart contract. Therefore we have to adapt the protocol in step 7.&lt;/p&gt;

&lt;p&gt;One immediate thought is to put the private key \(s\) in the contract. That doesn’t directly work, since if the key is in the contract then anyone can create their own signed tokens.&lt;/p&gt;

&lt;p&gt;Building on that idea, we adapt the protocol to have three phases: commitment phase, key submission phase, redeem phase.&lt;/p&gt;

&lt;p&gt;In the commitment phase, users submit their signed tokens \(R\). In the key submission phase, the server submits their key \(s\) to the contract. New tokens will not be accepted anymore. In the redeem phase, users can submit \(t\) and match it with an \(R\) submitted in the commitment phase. This prevents users from using the published key \(s\) to create new tokens.&lt;/p&gt;

&lt;p&gt;There is another problem which we’ll need to handle - front-running. Since now redeeming is all done on-chain, a malicious actor can see the activity a user performs with the contract and front-run both the commitment and the redeem phases. A clever user may notice it, but maybe not. There’s an easy way to prevent it though. Make token \(t\) be a public key, to which the user holds the private key. Then, when redeeming, the contract will verify a signature by that public key. The only thing a front-runner can now do is denial-of-service, but they can’t steal a user’s token.&lt;/p&gt;

&lt;p&gt;The protocol now looks as follows.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Initialize the contract with an operator and empty commitment mapping \(C\) and redeem mapping \(D\), and start with the commitment phase.&lt;/li&gt;
  &lt;li&gt;Users send their signed tokens \(R\) from a public key \(u\). The contract saves in the commitment mapping \(C[u]=R\).&lt;/li&gt;
  &lt;li&gt;The server then disables further sending of commitments, and moves to the key submission phase.&lt;/li&gt;
  &lt;li&gt;The server then submits its key \(s\).&lt;/li&gt;
  &lt;li&gt;The users now submit their tokens \(t\), of which the content is the public key \(u\), to the contract.&lt;/li&gt;
  &lt;li&gt;The contract computes \(sH(t)\), checks a signature by \(u\) on the redeem transaction, and checks whether \(C[u]=sH(t)\).&lt;/li&gt;
  &lt;li&gt;If successful, the contract transfers the reward to the user’s public key \(u\).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;starknet&quot;&gt;StarkNet&lt;/h1&gt;

&lt;p&gt;Now that we have designed StarDrop for an on-chain smart contract, and as a consequence to a zkrollup, we can move on to implement it in StarkNet!&lt;/p&gt;

&lt;p&gt;StarkNet is a zkrollup that allows writing smart contracts. This is in contrast to the original deployments of zkrollups that could perform only payments. In that manner, it is similar to zkSync aims to achieve.&lt;/p&gt;

&lt;p&gt;StarkNet works in a model where there’s an operator that executes the contracts and creates a proof for them. The user just provides the input. StarkNet uses Cairo under the hood, which is a language that compiles down to VM bytecode a STARK proof can created about.&lt;/p&gt;

&lt;p&gt;Cairo supports &lt;em&gt;hints&lt;/em&gt;, which are a way to provide precomputed inputs to a STARK to make the proof more efficient. These hints are computed using Python programs in Cairo. Running any Python code in StarkNet would then provide a denial-of-service vector against the operator, so StarkNet only allows specific methods to be used with hints, such as signature verification.&lt;/p&gt;

&lt;p&gt;Moreover, Cairo is a high level language. There are operations that are significantly more efficient if implemented directly in the low-level AIR representation of the program. Therefore, Cairo uses a few “built ins”, such as for performing a range check.&lt;/p&gt;

&lt;h1 id=&quot;implementation-of-stardrop-in-starknet&quot;&gt;Implementation of StarDrop in StarkNet&lt;/h1&gt;

&lt;h2 id=&quot;hash-to-curve&quot;&gt;Hash to curve&lt;/h2&gt;

&lt;p&gt;The hash \(H\) takes a string and outputs an element in the elliptic curve with an unknown discrete logarithm against other outputs of the hash. Ideally, it would behave as a good random oracle. Currently in StarkNet, the only hash efficiently available is a Pedersen hash, which does produce a point in the curve, but has algebraic properties that make it visibly different from a random oracle.&lt;/p&gt;

&lt;p&gt;Looking at a simplified version of a Pedersen hash, where the hash of \(b_0b_1\) is \(b_0G_1+b_1G_2\), we can give an example. Given the the hashes of \(01\) and \(10\), we can compute the hash of \(11\) without calling the hash function. This is true since \(H(01) = G_2\) and \(H(10) = G_1\), and so \(H(11) = H(01) + H(10) = G_1+G_2\).&lt;/p&gt;

&lt;p&gt;This would have to be improved before using this system securely.&lt;/p&gt;

&lt;h2 id=&quot;scalar-multiplication&quot;&gt;Scalar multiplication&lt;/h2&gt;

&lt;p&gt;Being limited to the type of code we can run, we soon stumble into a problem. Step 6 in our protocol requires us to perform a scalar multiplication, and we don’t have an efficient method to do it. Can we still do it? The answer is yes!&lt;/p&gt;

&lt;p&gt;An easy way is to implement &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Elliptic_curve_point_multiplication&quot; target=&quot;_blank&quot;&gt;affine addition and doubling formulas&lt;/a&gt;. For those coming directly from the SNARK world, this would seem problematic - these formulas have exceptions and conditionals are needed unless you can avoid the exceptions. All the branches in a SNARK are always executed, which can become expensive. This is not as big of an issue in StarkNet, since it runs the Cairo VM, and so the programming model is similar to a CPU, where you only pay forthe branch that is actually executing.&lt;/p&gt;

&lt;p&gt;An alternative exception-free approach would have been to implement &lt;a href=&quot;https://eprint.iacr.org/2015/1060.pdf&quot; target=&quot;_blank&quot;&gt;complete addition and doubling formulas&lt;/a&gt;, but that would likely be more expensive since the number of multiplications needed is larger.&lt;/p&gt;

&lt;p&gt;We’re still not done - in order to implement the “double and add” method, we need the binary representation of the key. Usually I would do it by providing the binary representation as a hint and checking that when summing it with the relevant powers of 2 we get the scalar. Since we can’t use arbitrary hints, we ask the user to provide these hints when claiming the drop. We then check the representation is correct and solely composed of bits. Alternatively, we could ask the operator to provide the representation when submitting their key.&lt;/p&gt;

&lt;h2 id=&quot;contract-and-scripts&quot;&gt;Contract and scripts&lt;/h2&gt;

&lt;p&gt;StarDrop is implemented as a StarkNet contract and a collection of Python scripts. The operation is quite manual at this point, but it’s fully functional. The implementation &lt;a href=&quot;https://github.com/kobigurk/stardrop&quot; target=&quot;_blank&quot;&gt;is available on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The usual workflow looks like (including example invocations):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator initializes the contract using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initialize&lt;/code&gt; function:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function initialize --inputs 3582577746677722431740023720320633876956623133930419590527228763639578535453 1000 2&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users can now submit signed tokens to the contract. To obtain them, they use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blind.py&lt;/code&gt; to create a blinded requests and send it to the operator off-chain. Then the operator uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sign_token.py&lt;/code&gt; and send the signed blinded token and correctness proofs to the user. The user then runs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unblind.py&lt;/code&gt; to get the unblinded signed token and verify the correctness proofs. Finally, the user sends the commitment to the contract:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function commit --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954 3261967588085170658862293428587059222438269839015135942205506249609410833918 383622200922475827691447562161872358420401626548600386003465214370732507533 166731635083539346047790634754225714698968525453493336513299480525988223874&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator then ends the commitment phase using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end_commitment_phase.py&lt;/code&gt; and uses the resulting signature:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function end_commitment_phase --inputs 1572514341211381639146744466808246693800547744347028176296700256447030933678 1978481093464076802357781694214950813691007442586456313662641217350746463161&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator submits the key to the contract using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit_key.py&lt;/code&gt; and uses the resulting signature:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function submit_key --inputs 284697472624386009295839589936418945178 3224560532100339074740113102065711825633396413956247303725126014773482991514 2291167198440858938698896566523731692215085667023695658054610128415429789324&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users can now claim their rewards by providing their public key and hints about operator’s key and the token:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function claim_drop --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954 1409864911388159352029816777278381225970523230642148213329717159060539927901 0 1 0 1 1 0 0 1 0 0 0 1 1 1 1 0 0 1 0 1 1 0 0 0 1 1 1 0 0 0 1 0 0 1 1 0 1 1 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 1 1 0 1 1 1 1 0 1 1 0 1 0 1 0 1 0 0 1 0 0 1 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 0 1 1&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;At this point, the user’s balance has increased and the pool’s balance has decreased. This can be checked:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet call --address $${ADDR} --abi contract_abi.json --function get_balance --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet call --address $${ADDR} --abi contract_abi.json --function get_pool_balance&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;StarkNet Planets, the currently deployed version of StarkNet, is already an expressive zkrollup and fits a lot of our needs, it has a few limitations. An important one is that it doesn’t support inter-contract communication in L2 or L1 ↔ L2 communication.&lt;/p&gt;

&lt;p&gt;This means that currently the contract can only track balances that users have internally and not actually transfer token that user can use. The changes needed to make that happen once it does support those are small.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;StarkNet’s programmability opens up interesting application possibilities and provides a lot of flexibility as to what can be implemented. The CLI tooling is easy to use and the developers and users don’t have to maintain any heavy machinery to create proof or use it. Furthermore, the VS code extension adds useful syntax highlighting.&lt;/p&gt;

&lt;p&gt;I did hit a few snags and additionally have some improvement suggestions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I managed to kill StarkNet testnet deployment! When using the built in methods, their import order makes a difference, and crashed the StarkNet operator when specified in the wrong order, causing it to stop producing blocks. Kudos to the team that fixed it promptly, and now reject contracts that use the wrong import order. This is reasonable for software in such an early stage and that’s what testnets are for 🙂&lt;/li&gt;
  &lt;li&gt;The testing workflow is hard. This is because there’s no way to run a StarkNet operator or a simulator of it locally, and so you have to wait for it to process your requests, which can take several minutes. That said, if there are exceptions and not just logic errors, the StarkNet operator reports them early and doesn’t wait for the actual execution.&lt;/li&gt;
  &lt;li&gt;The Cairo syntax is sometimes overly verbose and sometimes overly implicit. For example, when using built ins, you have to explicitly specify whether a function uses it, but then they’re usually implicitly passed to underlying functions. This was also confusing to me when dealing with “revoked references”, having to localize the implicitly passed built ins to prevent that from happening, per Lior’s advice.&lt;/li&gt;
  &lt;li&gt;Exceptions and asserts can occur at any time and it’s unclear whether an underlying function is safe to call with unchecked inputs. To be fair, this is a problem with most ZKP languages today.&lt;/li&gt;
  &lt;li&gt;I haven’t put a lot of consideration to costs. Currently, StarkNet doesn’t charge you for transaction, and there will be fees in the future. It’s likely we’d want to move some of the heavier computation to be paid by the operator.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall the experience was great, and I’m looking forward for the next versions!&lt;/p&gt;

&lt;h1 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h1&gt;

&lt;p&gt;I thank Louis, Tom and Lior a lot for answering my questions when working on this experiment.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">This post is about an experimental project to distribute rewards in a privacy-preserving manner running on StarkNet.</summary></entry><entry><title type="html">PLONK custom gates design considerations</title><link href="/2021/05/20/plonk-custom-gates.html" rel="alternate" type="text/html" title="PLONK custom gates design considerations" /><published>2021-05-20T00:00:00+03:00</published><updated>2021-05-20T00:00:00+03:00</updated><id>/2021/05/20/plonk-custom-gates</id><content type="html" xml:base="/2021/05/20/plonk-custom-gates.html">&lt;p&gt;Thanks to Zac Williamson and Kev for explaining ideas that helped form this document. Thanks to Han for spotting a mistake in “Approach 2” of the MiMC custom gate that could lead to breaking soundness.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;PLONK has flexible arithmetization, and can quite easily express complex polynomial gates. “Basic PLONK”, as defined in the &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;paper&lt;/a&gt;, defines only fan-in 2 arithmetic gates. The purpose of this document is to show what are custom gates and how they affect the performance of a PLONK proof.&lt;/p&gt;

&lt;p&gt;At a high level, PLONK defines the gates as part of a “quotient polynomial” \(t(x)\) - if this polynomial is zero at the points that represents gates, then the constraint system is satisfied.&lt;/p&gt;

&lt;p&gt;The arithmetic gate contribution to the quotient polynomial is defined as:&lt;/p&gt;

\[a(X)b(X)q_M(X) + a(X)q_L(X) + b(X)q_R(X) + c(X)q_O(X) + PI(X) + q_C(X)\]

&lt;p&gt;For example, a multiplication gate that calculates \(xy = z\) is going to have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
\[a(g^i) = x\]
  &lt;/li&gt;
  &lt;li&gt;
\[b(g^i) = y\]
  &lt;/li&gt;
  &lt;li&gt;
\[c(g^i) = z\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_M(g^i) = 1\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_O(g^i) = -1\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_L(g^i), q_R(g^i), PI(g^i), q_C(g^i) = 0\]
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;basic-plonk&quot;&gt;Basic PLONK&lt;/h1&gt;

&lt;p&gt;“Basic PLONK” has the following performance characteristics:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Proof size of \(9\mathbb{G}_1\) + \(7\mathbb{F}\) arising from:
 a. Commitments to the wires polynomials \(a(x)\), \(b(x)\), \(c(x)\)
 b. Commitment to the permutation polynomial \(z(x)\)
 c. Commitments to 3 \(n-\)degree polynomials, components of the \(3n-\)degree quotient polynomial \(t(x)\)
 d. Commitment to the opening polynomial \(W_z(x)\), ensuring sure the evaluations of \(t(x), r(x), a(x), b(x), c(x), S_{\sigma_1}, S_{\sigma_2}\) are correct at \(z\)
 e. Commitment to the opening polynomial \(W_{zw}(x)\), ensuring the evaluation of \(z(x)\) is correct at \(zw\)&lt;/li&gt;
  &lt;li&gt;Proving complexity of:
 a. \(9n\) \(\mathbb{G}_1\) exponentiations resulting from computing commitments of polynomials of degree \(n\): 3 from 1a, 1 from 1b, 3 from 1c, 1 from 1d, 1 from 1e
 b. Roughly \(54n\) field operations from FFTs:
    &lt;ul&gt;
      &lt;li&gt;8 of degree \(4n\) from:
        &lt;ul&gt;
          &lt;li&gt;The contribution of the permutation argument - 3 for $$\sigma_{0,1,2}&lt;/li&gt;
          &lt;li&gt;1 for \(z\)&lt;/li&gt;
          &lt;li&gt;3 for the \(a, b, c\) wires polynomials&lt;/li&gt;
          &lt;li&gt;1 inverse transform for the quotient polynomial itself at degree \(4n\)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;6 of degree \(2n\) from:
        &lt;ul&gt;
          &lt;li&gt;The contribution of the arithmetic gate - \(q_M, q_L, q_R, q_O\) and \(q_C\)&lt;/li&gt;
          &lt;li&gt;1 inverse transform for the quotient polynomial itself at degree \(2n\)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;12 of degree \(n\) from:
        &lt;ul&gt;
          &lt;li&gt;12 inverse transforms on all the polynomials we need to perform FFT on&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Verification complexity of (discounting field operations and hashes):
    &lt;ul&gt;
      &lt;li&gt;18 exponentiations in \(\mathbb{G}_1\):
        &lt;ul&gt;
          &lt;li&gt;6 from the linearization polynomial opening:
            &lt;ul&gt;
              &lt;li&gt;5 from the arithmetic gate polynomials \(q_M, q_L, q_R, q_O\) and \(q_C\)&lt;/li&gt;
              &lt;li&gt;1 from the \(z\) polynomial&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;9 from the quotient polynomial opening:
            &lt;ul&gt;
              &lt;li&gt;3 from the \(n-\)degree parts of \(t\)&lt;/li&gt;
              &lt;li&gt;3 from the wire polynomials \(a, b\) and \(c\)&lt;/li&gt;
              &lt;li&gt;2 from the permutation polynomials \(s_{\sigma1}, s_{\sigma2}\)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;1 from the evaluation commitment - containing all the evaluations of the opened polynomials&lt;/li&gt;
          &lt;li&gt;1 from the polynomial commitment argument for evaluation at \(z\) - the random opening point&lt;/li&gt;
          &lt;li&gt;1 from the polynomial commitment argument for evaluation at \(zw\) - the random opening point + 1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given \(n\) being the number of arithmetic gates, basic PLONK has a quotient polynomial of degree \(3n\). The arithmetic gate part itself has only degree \(2n\), and the \(3n\) degree stems from the permutation argument on the wire polynomials.&lt;/p&gt;

&lt;h1 id=&quot;designing-a-custom-gate&quot;&gt;Designing a custom gate&lt;/h1&gt;

&lt;p&gt;When designing a custom gate, you can change multiple characteristics.&lt;/p&gt;

&lt;h2 id=&quot;existing-wires&quot;&gt;Existing wires&lt;/h2&gt;

&lt;p&gt;If you’re introducing a new polynomial gate on existing wires, you affect:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Quotient polynomial contribution, which defines the constraints the custom gate verifies&lt;/li&gt;
  &lt;li&gt;Linearization polynomial contribution, which defines a partially evaluated quotient polynomial contribution, such that the contribution doesn’t contain polynomial products of committed polynomials&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you increase the degree of the quotient polynomial, you will affect:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;lt; 3n\), then you pay in FFTs of degree \(2n\) on new selector polynomials, and if there’s a product of selector polynomials, then opening of some of them until you reach a linear polynomial&lt;/li&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;gt; 3n, \leq 4n\) (meaning the degree of the quotient polynomial is still \(\leq 3n\)), then you similarly pay in openings and FFTs become of degree \(4n\)&lt;/li&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;gt; 4n\) and we still want to use the same fast-proving method, you pay in:
    &lt;ul&gt;
      &lt;li&gt;Similarly, in openings&lt;/li&gt;
      &lt;li&gt;FFTs of degree \(&amp;gt;4n\). E.g., if degree is \(5n\) and assuming radix-2 FFTs, then FFT of degree \(8n\)&lt;/li&gt;
      &lt;li&gt;Another commitment for every \(n-\)degree increase, making the proof larger by one group element and an additional scalar multiplication of size \(&amp;lt;=n\). Additionally, the verifier will pay a scalar multiplication for each \(n-\)degree increase&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Additionally, you pay a scalar multiplication in verification for each selector polynomial you introduce.&lt;/p&gt;

&lt;h2 id=&quot;adjacent-wires&quot;&gt;Adjacent wires&lt;/h2&gt;

&lt;p&gt;If you’re introducing adjacent wires (\(a_{i+1}, b_{i+1}, c_{i+1}\)), you need to add the opening of these values at \(zw\), so 1 additional field element for each of the required openings, but no significant increase in prover/verifier times - the prover needs to evaluate at the new points, and the verifier already has a polynomial commitment opening at \(zw\), so it folds into that&lt;/p&gt;

&lt;h2 id=&quot;further-wires&quot;&gt;Further wires&lt;/h2&gt;

&lt;p&gt;If you want access to more wires, e.g. \(a_{i+k}, b_{i+k}, c_{i+k}\), you similarly needs an opening at \(zw^{k}\), so 1 additionaly field element for each of the required openings. The prover similarly to the adjacent wires case needs to evaluate at additional points. There is another significant cost increase for both the prover and the verifier though - the prover needs to commit to the opening polynomial at \(zw^{k}\), which is another \(n-\)degree exponentiation and an additional group element in the proof, and the verifier has to open it, requiring an additional scalar multiplication.&lt;/p&gt;

&lt;h2 id=&quot;additional-wires&quot;&gt;Additional wires&lt;/h2&gt;

&lt;p&gt;If you’d like to introduce additional wires above \(a,b,c\), you could do it in multiple ways.&lt;/p&gt;

&lt;p&gt;One way is to introduce wires that are accessible throughout all the gates - introduce more \(n-\)degree polynomials, e.g. \(d(x), e(x)\) and so on. This would cause:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Increase of the permutation polynomial degree, causing the quotient polynomial degree to increase, and in turn increase the FFT degrees, a commitment and a scalar multiplication for each additional wire polynomial because of the \(n-\)degree increase in the quotient polynomial&lt;/li&gt;
  &lt;li&gt;An additional group element in the proof for each additional wire - a commitment to the wire polynomial&lt;/li&gt;
  &lt;li&gt;An additional field element in the proof for each additional wire - the evaluation of the corresponding \(S_{\sigma_i}\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another way is to introduce wires that are accessible only for half of the gates, i.e. for the use in exotic gates.&lt;/p&gt;

&lt;p&gt;Zac wrote about it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The trick is to add a second verification equation for your basic plonk gates.

Split each degree-n A(X), B(X), C(X) into two degree n/2 polynomials A1(X), A2(X), B1(X), B2(X), C1(X), C2(X).

Also do this splitting process with the selector polynomials Qm(X), Ql(X), Qr(X), Qo(X), Qc(X).

In addition to the original plonk gate equation, add a second:

Qm2(X).A2(X).B2(X) + Ql2(X).A2(X) + Qr2(X).B2(X) + Qo2(X).C2(X) + Qc2(X) + 0 mod Z_H(X)

You can then add in additional verification equations for exotic gates with 6 wires.

Because the degrees of your polynomials are half what they used to be, prover compute times haven’t increased (2x the polynomials, but the degrees have been halved). 

The permutation check now operates on six witness polynomials instead of three - so the maximum degree of your quotient polynomial is still degree 3n.

This also gives you some extra wiggle room - your exotic 6-wire gate equation can be a degree-6 polynomial, without increasing the degree of the quotient polynomial

The trade off with all of this, is increased verification time and increased proof size - each new selector polynomial and each new wire commitment will add 1 scalar mul into the verification equations, which starts to add up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;example---mimc7&quot;&gt;Example - MiMC7&lt;/h1&gt;

&lt;p&gt;To calculate a MiMC7 round function for round \(i\), we need to calculate \((x+k+c_i)^7\), where \(x,k\) are inputs and \(c_i\) is a constant&lt;/p&gt;

&lt;h2 id=&quot;approach-1---using-arithmetic-gates&quot;&gt;Approach 1 - using arithmetic gates&lt;/h2&gt;

&lt;p&gt;We would define the following gates:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;An add gate to calculate \(t = x+k+c_i\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^2\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^3\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^6\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to claculate \(t^7\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In total, 5 constraints.&lt;/p&gt;

&lt;h2 id=&quot;approach-2---using-a-custom-gate-of-degree-7&quot;&gt;Approach 2 - using a custom gate of degree 7&lt;/h2&gt;

&lt;p&gt;We augment the quotient polynomial with the following contribution:&lt;/p&gt;

\[(c(x) - (a(x) + b(x) + q_{mc}(x))^7)q_{mimc}(x)\]

&lt;p&gt;This makes the quotient polynomial of degree \(7n\).&lt;/p&gt;

&lt;p&gt;Assuming we’re still using the fast-proving method, this adds 2 scalar multiplications for the verifier, for the two new selector gates. The verifier also pays by 4 additional scalar multiplications because of the 4 degree increase in the quotient polynomial.&lt;/p&gt;

&lt;p&gt;The proof becomes larger by 4 group elements.&lt;/p&gt;

&lt;h2 id=&quot;approach-3---using-a-custom-gate-of-degree-3-and-an-adjacent-wire&quot;&gt;Approach 3 - using a custom gate of degree 3 and an adjacent wire&lt;/h2&gt;

&lt;p&gt;We augment the quotient polynomial with the following contribution:&lt;/p&gt;

\[(((c(x) + a(x) + q_{mc}(x))^3 - b(x))\alpha + (c(x) + a(x) + q_{mc}(x)).b(x)^2 - c(xw) )\alpha^2)q_{mimc}(x)\]

&lt;p&gt;This gate works by verifying that \(b(x)\) contains the \(t^3\), and proceeds to put \(t^7\) in \(c_{i+1}\).&lt;/p&gt;

&lt;p&gt;The random \(alpha\) coefficients enforce that each individual term will be \(0\).&lt;/p&gt;

&lt;p&gt;This doesn’t increase the quotient polynomial degree, and thererfore proving times are similar - only a few more evaluations.&lt;/p&gt;

&lt;p&gt;We pay in:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;2 scalar multiplications by the verifier for the two new selectors \(q_{mc}(x), q_{mimc}(x)\)&lt;/li&gt;
  &lt;li&gt;Additional field element in the proof - \(c(zw)\)&lt;/li&gt;
  &lt;li&gt;Additional field element in the proof - \(q_{mc}(z)\)&lt;/li&gt;
  &lt;li&gt;We don’t pay in a field element for \(q_{mimc}(z)\) - it’s reflected in the linearizer&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We’ve listed a few methods to use the flexibility of the arithmetization step and listed different trade-offs a custom gate designer can take, together with an example of a MiMC7 gate.&lt;/p&gt;

&lt;p&gt;We hope that this note proves useful for those learning and using custom gates.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Thanks to Zac Williamson and Kev for explaining ideas that helped form this document. Thanks to Han for spotting a mistake in “Approach 2” of the MiMC custom gate that could lead to breaking soundness.</summary></entry><entry><title type="html">Sapling audit</title><link href="/2019/01/31/sapling-audit.html" rel="alternate" type="text/html" title="Sapling audit" /><published>2019-01-31T00:00:00+02:00</published><updated>2019-01-31T00:00:00+02:00</updated><id>/2019/01/31/sapling-audit</id><content type="html" xml:base="/2019/01/31/sapling-audit.html">&lt;p&gt;Cross-posting from Medium, where we describe the audit we performed to Zcash Sapling. &lt;a href=&quot;https://medium.com/qed-it/sapling-audit-9b531be9d30&quot; target=&quot;_blank&quot;&gt;Check it out here.&lt;/a&gt;&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Cross-posting from Medium, where we describe the audit we performed to Zcash Sapling. Check it out here.</summary></entry><entry><title type="html">Exploring Privacy Pass</title><link href="/2019/01/05/exploring-privacypass.html" rel="alternate" type="text/html" title="Exploring Privacy Pass" /><published>2019-01-05T00:00:00+02:00</published><updated>2019-01-05T00:00:00+02:00</updated><id>/2019/01/05/exploring-privacypass</id><content type="html" xml:base="/2019/01/05/exploring-privacypass.html">&lt;p&gt;This post explores Privacy Pass, a protocol which “lets users prove their identity across multiple sites anonymously without enabling tracking”. We will go through the protocol components and eventually see a &lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;fully-compatible implementation of Privacy Pass in Rust&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;privacy-in-the-internet&quot;&gt;Privacy in the internet&lt;/h2&gt;

&lt;p&gt;Privacy for users in the internet is often advocated for, and just as often, compromised. This happens for good reasons - creating social networks (i.e., Facebook), allowing smarter usage of our data (i.e., Gmail), convenience of usage (i.e., OAuth - “Login using Google”), Security (i.e., Cloudflare’s HTTPS-for-every-site and Denial-of-Service protection) and many other reasons.&lt;/p&gt;

&lt;p&gt;The privacy loss is usually not absolute - it allows privacy against some adversaries. For example, while Facebook has access to your personal data, it takes the responsibility of not exposing it to other users, and does it pretty well.&lt;/p&gt;

&lt;p&gt;It makes me glad when these services which potentially compromise privacy also take additional steps to re-introduce it in creative ways.&lt;/p&gt;

&lt;h2 id=&quot;cloudflares-crypto-week&quot;&gt;Cloudflare’s Crypto Week&lt;/h2&gt;
&lt;p&gt;One of the companies whose trade-offs I like is Cloudflare. I’ve been using their service for many years to easily introduce HTTPS to my websites without having to go through the usual complex processes of obtaining and managing an HTTPS certificate.&lt;/p&gt;

&lt;p&gt;A few weeks ago, Cloudflare had a &lt;a href=&quot;https://blog.cloudflare.com/tag/crypto-week/&quot; target=&quot;_blank&quot;&gt;Crypto Week&lt;/a&gt;, where each day they posted about newly-developed features, who use cryptography to improve their services, in aspects such as privacy.&lt;/p&gt;

&lt;p&gt;Although not part of the Crypto Week, this exposed me to a protocol Cloudflare supports since 2017 - &lt;a href=&quot;https://blog.cloudflare.com/cloudflare-supports-privacy-pass/&quot; target=&quot;_blank&quot;&gt;Privacy Pass&lt;/a&gt;. This protocol has been developed in collboration with academic researchers and is provided as a service by Cloudflare.&lt;/p&gt;

&lt;h2 id=&quot;privacy-pass&quot;&gt;Privacy Pass&lt;/h2&gt;

&lt;p&gt;The Privacy Pass protocol, &lt;a href=&quot;https://captcha.website/&quot; target=&quot;_blank&quot;&gt;as implemented in Cloudflare&lt;/a&gt;, attempts solving the following tension:&lt;/p&gt;

&lt;p&gt;Cloudflare would like to give access to websites to humans rather than, let’s say, mal-intentioned bots. To do that, Cloudflare requires users to solve a &lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot; target=&quot;_blank&quot;&gt;CAPTCHA&lt;/a&gt; when they have suspicion.
On the one hand, these challenges protect the websites - no non-humans may access the site. On the other hand, false-positives cause inconvenience to users. That puts the burden on Cloudflare to improve their human-detection capbalities without compromising on security too much.&lt;/p&gt;

&lt;p&gt;This is where Privacy Pass comes in. It allows a user to solve a CAPTCHA once and use this “proof-of-humanity” later on.&lt;/p&gt;

&lt;h2 id=&quot;the-protocol&quot;&gt;The protocol&lt;/h2&gt;

&lt;p&gt;Rather than outlying the protocol directly, I’d like to build it step-by-step, to highlight the importance of each of the components in the protocol, and why stopping at that level might not be enough.&lt;/p&gt;

&lt;h3 id=&quot;methodology&quot;&gt;Methodology&lt;/h3&gt;

&lt;p&gt;Methodology-wise, I believe the best way to understand a topic is being able to teach it. In teaching, there are multiple levels. Two of these are teaching another human (outlying the theory, proofs, math) and teaching a machine (implementing it so it can be used).&lt;/p&gt;

&lt;p&gt;While teaching another human is highly valuable, some aspects are more readily exposed and understood when teaching a machine. This is one of the reasons I’ve chosen to &lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;implement Privacy Pass in Rust&lt;/a&gt; - in this way I could see the nitty-gritty details of how Cloudflare and the researchers made Privacy Pass work in practice.&lt;/p&gt;

&lt;h3 id=&quot;detecting-a-human&quot;&gt;Detecting a human&lt;/h3&gt;

&lt;p&gt;Cloudflare uses CAPTCHAs to detect humans when suspicion arises. Essentially, Cloudflare presents a challenge with weird-looking letters and numbers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/captcha.jpg&quot; alt=&quot;CAPTCHA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The user then provides the solution to what they think is the solution. If Cloudflare approves it, they allow the user through.&lt;/p&gt;

&lt;p&gt;Recall that the goal of Privacy Pass is to carry this “proof-of-humanity” to other situations where the user might be suspected.&lt;/p&gt;

&lt;p&gt;So why not, let’s say, when Cloudflare receives a correct solution, make Cloudflare send multiple “passes” which can be used in other sites?&lt;/p&gt;

&lt;p&gt;The answer lies in &lt;em&gt;tracking&lt;/em&gt;. When Cloudflare would send these passes to the user, they will know that these passes are related to the original CAPTCHA solution, and by so, to the original website where the user saw the challenge.&lt;/p&gt;

&lt;p&gt;If Cloudflare would have liked, they could track the user across multiple sites. To show a concrete example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, being at home, would have gone to kobi.one, see a challenge and solve it, let’s denote the solution \(S\). They would send the solution to Cloudflare, containing the solution \(S\) and natually their home IP.&lt;/li&gt;
  &lt;li&gt;Cloudflare would approve the solution, and send passes \(P_1, ... P_N\). Additionally, they would store in their database the connection between \(S\), each \(P_i\) and the user’s IP.&lt;/li&gt;
  &lt;li&gt;Next, when the user uses one of the passes in other websites, maybe from a coffee shop having a different IP, Cloudflare would be able to correlate the usage of pass \(P_i\) with the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cloudflare could obviously &lt;em&gt;not&lt;/em&gt; store this data, and that would require putting the trust in Cloudflare. While they might deserve it, you can do better.&lt;/p&gt;

&lt;h3 id=&quot;discerete-logarithm-problem&quot;&gt;Discerete Logarithm Problem&lt;/h3&gt;

&lt;p&gt;What if Cloudflare could provide the passes without being able to track their usage forward? Apparently, with some &lt;a href=&quot;http://en.wikipedia.org/wiki/Elliptic_curve_cryptography&quot; target=&quot;_blank&quot;&gt;elliptic-curve cryptography&lt;/a&gt;, it is possible.&lt;/p&gt;

&lt;p&gt;Without diving too much into elliptic-curves, I’ll remind some basic facts.&lt;/p&gt;

&lt;p&gt;Elliptic curves, being curves, have points. You can define the \(+\) operation on points, such that given points \(P\) and \(Q\) on the curve, you will get a third point \(R\) which is the result of \(P+Q\). To see how to define this visually, you can see it, for example, &lt;a href=&quot;https://www.certicom.com/content/certicom/en/21-elliptic-curve-addition-a-geometric-approach.html&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can also define adding a point \(G\) to itself \(n\) times (\(G+...+G\) with \(n-1\) additions). Call this operation \(n \cdot G\).&lt;/p&gt;

&lt;p&gt;You can ask, given points \(G\) and \(Y\), “how many times would I have to add \(G\) to itself in order to get \(H\)?” That is, what is the \(n\) such that \(n \cdot G = H\)? This is a hard problem in elliptic-curve cryptography, called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot; target=&quot;_blank&quot;&gt;Discrete Logarithm Problem&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;blind-signatures&quot;&gt;Blind signatures&lt;/h3&gt;

&lt;p&gt;Now we begin solving the problem of tracking. First, let’s expand our protocol and describe it in more detail.&lt;/p&gt;

&lt;p&gt;Let’s say the secret key of the Privacy Pass server is the number \(x\) and there’s a publicly known point on the curve called \(G\) and execute the protocol as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, requesting passes, will create a random token \(t\) and send the server the point \(t \cdot G\), denoting it \(T\). The server will not be able to know \(t\) because of the Discrete Logarithm Problem.&lt;/li&gt;
  &lt;li&gt;The server will create the point \(x \cdot T\). Let’s call it a &lt;em&gt;signature&lt;/em&gt; and denote it \(Z\). The user will not be able to uncover \(x\) because of DLP.&lt;/li&gt;
  &lt;li&gt;The server will send the signature to the user, which later on will be able to use this signature to prove they received it from the server. Since only the server knows \(x\), only the server could create \(Z = x \cdot T\), and so the server will know they have created these signatures.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This has the problem of tracking, since the server will be able to store all this data and correlate it to the user when the \(Z\)s is used by the user.&lt;/p&gt;

&lt;p&gt;The user, instead of sending \(T\) directly can use a &lt;em&gt;blinding factor&lt;/em&gt; \(r\) to create \(M = r \cdot T = r \cdot t \cdot G\). We call this a &lt;em&gt;blinded token&lt;/em&gt;. Now, when receiving the signature \(Z\) over each \(M\), the user will &lt;em&gt;unblind&lt;/em&gt; the signature by multiplying by the inverse of \(r\): \(r^{-1} \cdot Z = r^{-1} \cdot x \cdot M = r^{-1} \cdot x \cdot r \cdot T = r^{-1} \cdot r \cdot x \cdot T = x \cdot T\). Let’s denote this result \(N\).&lt;/p&gt;

&lt;p&gt;Although the user could cacluate \(N\), they could never generate it by themselves - since they don’t know \(x\). Presenting the server \(t\) and \(N\) allows the server to verify they indeed the ones who generated this signature, and the server will not know which &lt;em&gt;blinded token&lt;/em&gt; this signature relates to since they never knew the &lt;em&gt;blinding factor&lt;/em&gt; \(r\).&lt;/p&gt;

&lt;p&gt;The protocol now looks like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, requesting passes, will create a random token \(t\) and a blinding factor \(r\) and send the server the point \(r \cdot t\cdot G\), denoting it \(M\).&lt;/li&gt;
  &lt;li&gt;The server will create the point \(x \cdot M\). The server generates a signature \(Z\).&lt;/li&gt;
  &lt;li&gt;The server will send the signature to the user, and the user unblinds the signature, calculating and storing \(N=r^{-1} \cdot M\).&lt;/li&gt;
  &lt;li&gt;The user later on presents \(t\) and \(N\) to the server when they would like to prove their humanity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It sounds very good! Unfortunately, this doesn’t solve the problem of tracking, which might not be immediately obvious.&lt;/p&gt;

&lt;p&gt;Assuming the server uses the same secret key \(x\) for all the users requesting passes, this works well. What if the server uses a different \(x\) for every user? We’re right back to square one - the server, when verifying the signature, will be able to iterate over all the different \(x\)s they generated and thus identify the user.&lt;/p&gt;

&lt;p&gt;This is why it’s important for the server to show it indeed uses the same secret key \(x\) for all the users. This is done by using a &lt;em&gt;Discrete Logarithm Equality Proof&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;discrete-logarithm-equality-proof&quot;&gt;Discrete Logarithm Equality Proof&lt;/h3&gt;

&lt;p&gt;The server already publishes one point publicly - \(G\). The server could publish publicly an additional point \(Y=x \cdot G\). This is essentially a &lt;em&gt;commitment&lt;/em&gt; to the secret key \(x\).&lt;/p&gt;

&lt;p&gt;The construction of how &lt;em&gt;DLEQ&lt;/em&gt; works requires a bit more math, and I prefer not getting into it in this post. That said, I would like to give a few points to those interested:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It is similar to the Schnorr identification scheme, proving that the server knows the secret key \(x\) - essentially proving knowledge of “\(Y/G\)”.&lt;/li&gt;
  &lt;li&gt;It uses the non-interactive variant of the scheme using the Fiat-Shamir heuristic, which also has an &lt;a href=&quot;https://tools.ietf.org/html/rfc8235&quot; target=&quot;_blank&quot;&gt;IETF RFC&lt;/a&gt;, converting it from an &lt;em&gt;honest-verifier zero-knowledge&lt;/em&gt; scheme to a &lt;em&gt;non-interactive zero knowledge argument&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;Instead of only proving knowledge of \(Y/G\), it also shows that the &lt;em&gt;same&lt;/em&gt; proof applies to \(Z/M\). This means that the publicly committed secret key, as shown in \(Y\), is the &lt;em&gt;same&lt;/em&gt; one used to create \(Z\) for \(M\), proving that the server used the same secret key to generate the signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A nice description of &lt;em&gt;DLEQ&lt;/em&gt; and some of these details are described in &lt;a href=&quot;https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/&quot; target=&quot;_blank&quot;&gt;this post by Matthew Green&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you would like more details on the math inolved, feel free to &lt;a href=&quot;https://kobi.one/contact.html&quot; target=&quot;_blank&quot;&gt;reach out&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;finalizing-the-protocol&quot;&gt;Finalizing the protocol&lt;/h3&gt;

&lt;p&gt;By requiring &lt;em&gt;DLEQ&lt;/em&gt;, the server now can’t cheat and use different secret keys to track users. To make this protocol usable in practice, some other aspects should be considered:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Instead of sending a single token, the user could send multiple tokens to be signed at once.&lt;/li&gt;
  &lt;li&gt;The server should limit the amount of tokens the user can request for each CAPTCHA solution, to prevent abuse by a user dispensing these tokens to other users, essentially making the protection useless.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;The original open-source implementation of Privacy Pass by Cloudflare and the researchers is &lt;a href=&quot;https://github.com/privacypass&quot; target=&quot;_blank&quot;&gt;available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;My implementation of Privacy Pass in Rust is available here&lt;/a&gt;. Some details about it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is fully-compatible with the &lt;a href=&quot;https://github.com/privacypass&quot; target=&quot;_blank&quot;&gt;reference implementation&lt;/a&gt;, both as a server and as a client.&lt;/li&gt;
  &lt;li&gt;It uses &lt;a href=&quot;https://github.com/milagro-crypto/amcl&quot; target=&quot;_blank&quot;&gt;amcl&lt;/a&gt; for elliptic-curve cryptography.&lt;/li&gt;
  &lt;li&gt;It uses &lt;a href=&quot;https://github.com/rust-rocksdb/rust-rocksdb&quot; target=&quot;_blank&quot;&gt;RocksDB&lt;/a&gt; for storage.&lt;/li&gt;
  &lt;li&gt;It is probably compilable to WebAssembly or other architectures with minor modifications.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, it is easy to modify it to support any kind of challenge-solution use-case: login to systems, voting and many more.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Privacy Pass allows adding privacy to a system where initially it seems impossible, by the use of cryptography. It’s awesome to see that some companies, which have all the means to disregard privacy at the cost of convenience, still go through the R&amp;amp;D and risk required to re-introduce privacy to their systems.&lt;/p&gt;

&lt;p&gt;If you found this interesting and have more questions or suggestions, feel free to &lt;a href=&quot;https://kobi.one/contact.html&quot; target=&quot;_blank&quot;&gt;reach out&lt;/a&gt;, I’d love to hear from you!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">This post explores Privacy Pass, a protocol which “lets users prove their identity across multiple sites anonymously without enabling tracking”. We will go through the protocol components and eventually see a fully-compatible implementation of Privacy Pass in Rust.</summary></entry><entry><title type="html">Creating fake zkSNARK proofs</title><link href="/2018/07/16/creating-fake-zksnarks-proofs.html" rel="alternate" type="text/html" title="Creating fake zkSNARK proofs" /><published>2018-07-16T00:00:00+03:00</published><updated>2018-07-16T00:00:00+03:00</updated><id>/2018/07/16/creating-fake-zksnarks-proofs</id><content type="html" xml:base="/2018/07/16/creating-fake-zksnarks-proofs.html">&lt;h1 id=&quot;creating-fake-zksnark-proofs&quot;&gt;Creating fake zkSNARK proofs&lt;/h1&gt;

&lt;p&gt;As you may know, zkSNARKs are a way to create Zero-Knowledge Proofs.
Specifically, succinct and non-interactive ones.&lt;/p&gt;

&lt;p&gt;Explaining what they are exactly is a bit too much for this post, so I refer you
to the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://z.cash/technology/zksnarks.html&quot; target=&quot;_blank&quot;&gt;How zkSNARKs are constructed in &lt;/a&gt;
— by the Zcash team.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/06/08/trustless-computing/&quot; target=&quot;_blank&quot;&gt;Trustless Computing on Private
Data&lt;/a&gt; — blog post by
QED‐it’s lead cryptographer Daniel Benarroch and Prof. Aviv Zohar.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/04/zkp-in-action/&quot; target=&quot;_blank&quot;&gt;Prove-it, Blockchain-it: ZKP in
Action&lt;/a&gt; — a video of a meetup
explaining ZKPs and how to create one for Sudoku.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/12/20/the-incredible-machine/&quot; target=&quot;_blank&quot;&gt;The Incredible Machine&lt;/a&gt;
— blog post by QED‐it’s Chief Scientist Prof. Aviv Zohar, explaining trusted
setup.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/11/the-hunting-of-the-snark/&quot; target=&quot;_blank&quot;&gt;The Hunting of the
SNARK&lt;/a&gt; — a series of
riddles to experiment with ZKPs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In QED-it we use zkSNARKs, among other tools, to create Zero-Knowledge
Blockchains for the enterprise.&lt;/p&gt;

&lt;p&gt;The production deployment of zkSNARKs that is most known is probably
&lt;a href=&quot;http://z.cash/&quot; target=&quot;_blank&quot;&gt;Zcash&lt;/a&gt; — a cryptocurrency with unlinkable transactions and
hidden amounts. Zcash, and some others utilizing zkSNARKs, are based on a
construction called &lt;a href=&quot;https://eprint.iacr.org/2013/279&quot; target=&quot;_blank&quot;&gt;Pinnochio&lt;/a&gt;, although more
specifically &lt;a href=&quot;http://eprint.iacr.org/2013/879&quot; target=&quot;_blank&quot;&gt;BCTV14a&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is a marvelous technology, and as you might suspect, nothing is for free!
There’s a notable downside to this construction — the “trusted setup”.&lt;/p&gt;

&lt;h3 id=&quot;trusted-setup&quot;&gt;Trusted Setup&lt;/h3&gt;

&lt;p&gt;The setup is a process where the CRS (Common Reference String) is generated, or
more publicly known as the pair of proving and verification keys. These “keys”
are used by the prover and verifer to generate and verify proofs for a specific
problem (or constraint system), respectively.&lt;/p&gt;

&lt;p&gt;In this process, there are random elements which are sampled and must be kept
secret — if the prover knows them, they will be able to create proofs which are
verified successfully, without using an actual solution to the problem during
the proving process. In other words, to forge proofs and break soundness. This
randomness is also known as “toxic waste”.&lt;/p&gt;

&lt;p&gt;There are ways to avoid this worry and not put trust in a single entity. For
public circuits, these usually involve a Multi-Party Computation — a process in
which multiple players donate their own randomness, which they destroy
afterwards. The interesting fact is that it’s enough that one player is honest
and destroys their randomness for the whole process to be secure.&lt;/p&gt;

&lt;p&gt;Some notable examples of using MPCs to do trusted setup are again, by Zcash:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.wnycstudios.org/story/ceremony/&quot; target=&quot;_blank&quot;&gt;“The Ceremony” podcast&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://z.cash.foundation/blog/powers-of-tau/&quot; target=&quot;_blank&quot;&gt;Powers of Tau&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You might notice this “Tau” that popped up there…&lt;/p&gt;

&lt;p&gt;Not to insult any random element — Tau is very important to be kept secret. With
Tau known to the prover — it’s very easy to forge a proof!&lt;/p&gt;

&lt;h3 id=&quot;creating-a-proof&quot;&gt;Creating a proof&lt;/h3&gt;

&lt;p&gt;Let’s take a quick look at the construction presented in
&lt;a href=&quot;http://eprint.iacr.org/2013/879&quot; target=&quot;_blank&quot;&gt;BCTV14a&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fake1.png&quot; alt=&quot;&quot; style=&quot;width: 100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It’s math-heavy, so let’s cherry-pick bits of details relevant to this post:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Tau is a point in a finite field sampled at random, part of the “toxic waste”,
during the setup process.&lt;/li&gt;
  &lt;li&gt;The prover, during the proving process, calculates some polynomials — A(z),B(z)
and C(z), which are derived from the constraint system and the public and
private inputs to the solution. Essentially, these polynomials represent
constraints of the form “a&lt;em&gt;b=c”, or equivalently “a&lt;/em&gt;b-c=0”.&lt;/li&gt;
  &lt;li&gt;The prover also calculates H(z) = (A(z)B(z)-C(z))/Z(z), where Z(z) is a publicly
known polynomial which zeros at the points representing the constraint system.
Take note that since A,B and C take the inputs of the prover into account, H can
only be calculated when the numerator also zeros at the same points — attesting
to the fact the prover actually knows a solution to the problem, that which
yields A*B-C = 0.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The important part happens now — the prover, while not knowing Tau, can
calculate “in-the-exponent” H(z) evaluated at Tau — \(H(\tau)\)!&lt;/p&gt;

&lt;p&gt;Why do we do that? Since by evaluating at the random point Tau, the prover shows
with high probability that the equation H=(A*B-C)/Z holds for all z. From a
different perspective on the same matter, without knowing Tau, the prover, with
high probability, will not be able to produce a polynomial which receives the
exact same value at that point.&lt;/p&gt;

&lt;p&gt;How can we technically do that? By the fact that part of the setup process
generated elements containing all the relevant powers of Tau, hidden in the
exponent, given as \(pk_{H_i}\). If we have the coefficients of H, we can combine these
and create \(H(\tau)\).&lt;/p&gt;

&lt;p&gt;More specifically:&lt;/p&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(H(z) = \sum{h_i \cdot z^i }\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Calculated H(z) by the prover&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\({pk}_{H_i} = \tau^i \cdot G_i\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Taken from the proving key, calculated in the setup process&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\sum{h_i \cdot {pk}_{H_i} } = \sum{h_i \cdot \tau^i \cdot G_1} = H(\tau) \cdot G_1\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Evaluating \(H(\tau)\) “in-the-exponent”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The verifier, upon receiving the proof, can check, again in-the-exponent, that
the prover indeed provided coefficients for H which satisfy the relation
H=(A*B-C)/Z, which can only be done if the prover actually knew a solution.&lt;/p&gt;

&lt;h3 id=&quot;forging-a-proof&quot;&gt;Forging a proof&lt;/h3&gt;

&lt;p&gt;Now let’s have some fun… What happens if Tau is known? If, by some reason, it
was exposed during the setup process and is known to a malicious prover?&lt;/p&gt;

&lt;p&gt;Apparently, it’s very easy to forge a proof — since the equality check for
H=(A*B-C)/Z is done is at the specific point Tau, we can use our knowledge of
Tau to create a polynomial which satisfies exactly that! That is, create a
constant polynomial H(z), which just returns \((A(\tau) \cdot B(\tau)-C(\tau))/Z(\tau)\) all
the time.&lt;/p&gt;

&lt;p&gt;The verifier’s check will pass, and none’s the wiser!&lt;/p&gt;

&lt;h3 id=&quot;sounds-hard&quot;&gt;Sounds hard…&lt;/h3&gt;

&lt;p&gt;Not at all — you’re more than welcome to check &lt;a href=&quot;https://github.com/QED-it/libsnark-tutorial_forge_proof&quot; target=&quot;_blank&quot;&gt;this proof-of-concept
code&lt;/a&gt;, based on Howard
Wu’s &lt;a href=&quot;https://github.com/howardwu/libsnark-tutorial&quot; target=&quot;_blank&quot;&gt;libsnark-tutorial&lt;/a&gt;, and see
for yourself the changes made to the code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The program sets up a circuit for bit-decomposition — this is an example, and it could have been any circuit.&lt;/li&gt;
  &lt;li&gt;The setup process maliciously saves Tau to disk.&lt;/li&gt;
  &lt;li&gt;The prover loads Tau from disk, and uses wrong inputs to the proof. The prover,
knowing Tau, generates the constant polynomial, disregarding the inputs.&lt;/li&gt;
  &lt;li&gt;The verifier then verifies the proof successfully — bamboozled!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;I hope this post provided some insight into what is this “toxic waste” that
everyone has been talking about regarding zkSNARKs, and why having it exposed
leads to an easily executable attack.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">As you may know, zkSNARKs are a way to create Zero-Knowledge Proofs. They do require a trusted setup. What happens when the setup is compromised?</summary></entry><entry><title type="html">Zero-Knowledge taxation on Ethereum</title><link href="/2018/06/24/zkp-qed-ethereum.html" rel="alternate" type="text/html" title="Zero-Knowledge taxation on Ethereum" /><published>2018-06-24T00:00:00+03:00</published><updated>2018-06-24T00:00:00+03:00</updated><id>/2018/06/24/zkp-qed-ethereum</id><content type="html" xml:base="/2018/06/24/zkp-qed-ethereum.html">&lt;p&gt;At QED‐it, we have a mission to provide privacy preserving systems for the enterprise. For the last two years, we’ve worked on many projects, developing complex SNARK circuits and higher level protocols to tackle different use-cases - asset management, supply chain, real-time risk assessment, predictive maintenance, credit scoring and more.&lt;/p&gt;

&lt;p&gt;We are happy to present one such project that has been done in collaboration with Deloitte. The project has been in the works for the last few months, in which the team in Deloitte utilized the QED‐it SDK to deploy a Zero-Knowledge Blockchain for their chosen use-case — new french tax rules presented in 2018.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Watch the talk by Jonathan Rouach, our CEO, at ZCon0:&lt;/p&gt;
&lt;style&gt;.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }&lt;/style&gt;
&lt;div class=&quot;embed-container&quot;&gt;    &lt;iframe title=&quot;YouTube video player&quot; width=&quot;640&quot; height=&quot;390&quot; src=&quot;//www.youtube.com/embed/OTO4JCJZD2o&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h1 id=&quot;use-case&quot;&gt;Use-case&lt;/h1&gt;

&lt;p&gt;It is common for a person to purchase a life insurance contract from an insurer. The person then performs deposits to this contract. In “investment-type” contracts, these deposits are invested by the insurer in different investment vehicles, possibly earning gains.&lt;/p&gt;

&lt;p&gt;At some point, the person would like to withdraw their money from the insurer. The question arises - how should these gains be taxed, before paying to the person?&lt;/p&gt;

&lt;p&gt;This is where a friction point arises - the new 2018 french tax law binds the calculation of the tax to the &lt;em&gt;accumulated value&lt;/em&gt; of all life insurance contracts held by the beneficiary.&lt;/p&gt;

&lt;p&gt;When the person has contracts with a single insurer, then, naturally, all the data relevant for calculating the tax is held by this insurer. Since it is also possible for a person to purchase life insurance contracts from multiple insurers, a person might not want to expose this highly personal data to the insurer the person is withdrawing from.&lt;/p&gt;

&lt;p&gt;What if we had a system, allowing a person to use all of the life insurance contracts from their insurers, and calculate the tax the insurer should pay, without leaking information about other contracts at other insurers?&lt;/p&gt;

&lt;h1 id=&quot;zero-knowledge-proofs&quot;&gt;Zero-knowledge proofs&lt;/h1&gt;

&lt;p&gt;Zero-knowledge proofs (ZKPs) allow a verifier to pose a question to a prover, and the prover answers this question, using whatever private data needed to answer it, revealing nothing more than the answer to the question itself.&lt;/p&gt;

&lt;p&gt;An example of a question a verifier could pose is “do you know the solution to the following Sudoku puzzle?”. Obviously, the prover who knows the solution can show the solution itself. This prover, though, would like to keep the solution secret for now, but convince the verifier that they do know the solution. The prover can use a zero-knowledge proof to just answer “yes”! The cryptographic proof also serves for convincing the verifier that the right question was used on the right data and no one altered the result.&lt;/p&gt;

&lt;p&gt;zkSNARKs are, amongst other properties, a way to do this process:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Non-interactively&lt;/em&gt; - without a direct interaction between the prover and the verifier.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Succinctly&lt;/em&gt; - the proofs are very small.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Explaining zero-knowledge proofs in depth is beyond the scope of this post, and if you wish to know more, I invite you to check out the following resources:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/06/08/trustless-computing/&quot;&gt;Trustless Computing on Private Data&lt;/a&gt; - blog post by QED‐it’s lead cryptographer Daniel Benarroch and Prof. Aviv Zohar.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/04/zkp-in-action/&quot;&gt;Prove-it, Blockchain-it: ZKP in Action&lt;/a&gt; - a video of a meetup explaining ZKPs and how to create one for Sudoku.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/12/20/the-incredible-machine/&quot;&gt;The Incredible Machine&lt;/a&gt; - blog post by QED‐it’s Chief Scientist Prof. Aviv Zohar, explaining trusted setup.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/11/the-hunting-of-the-snark/&quot;&gt;The Hunting of the SNARK&lt;/a&gt; - a series of riddles to experiment with ZKPs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;the-project&quot;&gt;The project&lt;/h1&gt;

&lt;h2 id=&quot;qed-it-sdk&quot;&gt;QED-it SDK&lt;/h2&gt;
&lt;p&gt;At the heart of the QED‐it SDK is an &lt;em&gt;identity&lt;/em&gt; protocol. This protocol serves as a framework for committing to data by issuers, attesting pieces of data about a user, and allowing an auditor to pose audit questions to this user. The user, in turn, generates a zero-knowledge proof that combines the data inputs and uses a computation on them to answer the audit question.&lt;/p&gt;

&lt;p&gt;The QED‐it SDK provides this protocol adapted to families of use-cases, especially the ones discussed and deemed important in the recent &lt;a href=&quot;https://zkproof.org&quot;&gt;Zero Knowledge Proof Standardization&lt;/a&gt; workshop. The adaptations includes a set of building blocks for each of these families, allowing an auditor to pose increasingly complex audit questions.&lt;/p&gt;

&lt;p&gt;Why is it called an SDK? Well, the SDK allows developers to write “hooks” - their own audit questions using a Domain-Specific Language. The encompassing protocols provide the security guarantees required by most of the use-cases.&lt;/p&gt;

&lt;h2 id=&quot;high-level-design&quot;&gt;High-level design&lt;/h2&gt;

&lt;p&gt;Let’s start with a diagram describing the system:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zkpqed1.jpeg&quot; alt=&quot;System diagram&quot; style=&quot;width: 100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;User, Insurer 1 and Insurer 2 are QED‐it nodes. The nodes give the ability to publish commitments about bits of data and generate ZKPs in response to audit questions.&lt;/p&gt;

&lt;p&gt;Step-by-step (using the numbering of the diagram), this is how a possible system communication scenario looks like:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Insurer 1 sends the life insurance contract to the user, attesting to the contract between them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insurer 1 publishes commitments, in the form of hashes, of the contract. These are small values not exposing any information about the contract itself.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(This covers 3-8). The commitments are propagated throughout the network. Additionally, Insurer 2 does the same publishing steps as Insurer 1.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The user requests to leave Insurer 2. The insurer has to pay the gains to the user, minus the taxes owed for them. In order to know the tax amounts, the insurer poses an audit question to the user - “given your life insurance contracts at all of your insurers, what is the tax amount that should be paid for the gains for the deposits you made to us?”&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The user collects all their life insurance contracts, and generates a zero-knowledge proof of the calculated tax amounts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;After receiving the ZKP, Insurer 2 pays the user, minus the taxes on the gains according to the law, all this without knowing any details about the other life insurance contracts the user holds! (Except, of course, what can be inferred from the audit question itself)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I’d like to highlight an important fact which may not be obvious - throughout this process, the data, once collected by the user, never left the user’s node! Still, the user can calculate by themselves the tax rates, with the insurer being certain that the result is correct.&lt;/p&gt;

&lt;p&gt;In a centralized world, in order for the insurers to comply with the law, they must have more information, and so the user usually provides it to them. In the QED-it world, it’s not like that anymore! The users perform the math on their own machines, and they just need the right infrastructure to support this - users running QED-it nodes to generate ZKPs and insurers committing data and verifying proofs.&lt;/p&gt;

&lt;h2 id=&quot;modularization-and-domain-specific-language-dsl&quot;&gt;Modularization and Domain-Specific Language (DSL)&lt;/h2&gt;

&lt;p&gt;QED‐it’s SDK allows users to write their “business-logic” proofs both in our embedded DSL and and other external DSLs - languages for the domain of Zero-Knowledge Proofs.&lt;/p&gt;

&lt;p&gt;The main requirement for this integration is that the proofs conform to the &lt;em&gt;proof-chaining&lt;/em&gt; specification. Proof-chaining is a technique we’ve implemented that allows a prover to connect different proofs parts, even between different proof systems. This allows the DSL proofs to be connected  with the other parts of the QED‐it’s proofs and protocol.&lt;/p&gt;

&lt;p&gt;A bit more in-depth, the proof in this use-case is modularized to multiple proofs, “glued” together:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Data validity proofs.&lt;/em&gt; These promise:
    &lt;ol&gt;
      &lt;li&gt;The data has been published before by one of the approved parties, and existed by block X, referenced by a “merkle root” of the merkle tree generated by all the published commitments.&lt;/li&gt;
      &lt;li&gt;The data has not been revoked by block Y.&lt;/li&gt;
      &lt;li&gt;The subset of the data that will be chained to the next proof has been generated correctly, referenced by a hiding commitment to it.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;As you may notice, we’ve introduced a new concept here, a Merkle tree. Specifically, the commitments in the system are collected in an append-only Merkle tree - a data structure that has efficient proofs for “set membership” -given a set S and an element x, you can efficiently show x is an element in the set S.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Tax proof.&lt;/em&gt; This is the proof containing the specific business logic of the proof, which in this case means the calculation of the tax amounts. This proof assumes the data inputs have been validated by other proofs. This assumption causes this proof to be very small and efficient!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The different proof components are connected by what we call a glue.&lt;/p&gt;

&lt;p&gt;The verification protocol then, in addition to verifying that the merkle roots existed in the past, includes verification of the “glue” components between the different proofs.&lt;/p&gt;

&lt;p&gt;The calculation of tax amounts in the &lt;em&gt;Tax Proof&lt;/em&gt; has been written by Alizée Faytre, who has been the developer in Deloitte working on the project under the supervision of Ossama Benbouidda and Julien Maldonato, using &lt;a href=&quot;https://github.com/JacobEberhardt/ZoKrates&quot;&gt;ZoKrates&lt;/a&gt; — a Python-like high level language that compiles into zkSNARKs.&lt;/p&gt;

&lt;h2 id=&quot;external-verifiers&quot;&gt;External verifiers&lt;/h2&gt;

&lt;p&gt;An important part of this project was allowing an external party who is not running a QED‐it node to enjoy the results of the zero-knowledge proof generated by the user’s QED‐it node.&lt;/p&gt;

&lt;p&gt;To do that, we chose to deeply integrate with an Ethereum network, which, since the &lt;a href=&quot;https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/&quot;&gt;Byzantium hard-fork&lt;/a&gt;, allowing zkSNARKs proofs verification by providing precompiles for efficient evaluation of elliptic curve operations on the BN128 curve. In short, this means that we can generate proofs using a QED-it node and verify them in a decentralized manner on the Ethereum blockchain.&lt;/p&gt;

&lt;p&gt;We implemented a smart contract that essentially acts as an autonomous verifier. This smart contract allows the different parties to publish commitments that will be collected in an incremental merkle tree, and run the verification protocol on the bundle of proofs generated by the user.&lt;/p&gt;

&lt;p&gt;This allows, for example, for a smart contract managing the wallet of the insurer, to consume the tax proofs, pay the taxes to the government and pay the user minus the tax. This coincides with our vision of real-time regulation compliance.&lt;/p&gt;

&lt;h2 id=&quot;the-system-in-action&quot;&gt;The system in action&lt;/h2&gt;

&lt;p&gt;We deployed the system comprising a set of 6 nodes - 5 insurers and 1 user, running a Proof-of-Authority Ethereum network. These parties run QED‐it nodes and have the ability to generate these proofs, using our own efficient data validity proofs and to generate the tax proof using ZoKrates.&lt;/p&gt;

&lt;p&gt;The nodes are easily deployable using Docker and are exposing an HTTP API to be easily integrated with.&lt;/p&gt;

&lt;p&gt;Along with its node, comes QED-it’s explorer tool, that realizes our vision of a ZKP monitoring system and allows operators of nodes to monitor the activity of their nodes, just like a block explorer allows one to monitor a blockchain. This is how the process looks like there:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data report by an insurer:
&lt;img src=&quot;/assets/images/zkpqed2.png&quot; alt=&quot;Data report&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Commitment publish by an insurer:
&lt;img src=&quot;/assets/images/zkpqed3.png&quot; alt=&quot;Commitment publish&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Tax calculation result:
&lt;img src=&quot;/assets/images/zkpqed4.png&quot; alt=&quot;Audit&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;challenges&quot;&gt;Challenges&lt;/h2&gt;

&lt;p&gt;This project uses bleeding-edge technology, and as you can imagine, it posed a few challenges:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The smart contract implementing the autonomic verifier has to maintain a history of “known merkle roots” - each time a commitment is published to the contract, the new root should be calculated and kept.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Doing this naively is an issue - as this is an incremental tree, commitments are never deleted, so it’s best to use as large as possible tree. We chose a tree of depth 30, supporting about a billion of commitments. Managing this large a tree directly in a smart contract is not practical.&lt;/p&gt;

&lt;p&gt;To cope with that, we implemented an efficient incremental merkle tree in Solidity.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The gas requirements for the pairing operations needed to verify proofs are pretty high - verifying a single proof consumes about 2 million gas.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is where the different trade-offs between the systems come into friction - on the one hand, modularization of proofs allows for more versatile, practical and secure proofs, and on the other hand, we would like to minimize the amount of gas used in the contract.&lt;/p&gt;

&lt;p&gt;There are possibilities to make good trade-offs - using different modularization techniques, combining proofs using &lt;a href=&quot;http://eprint.iacr.org/2012/095&quot;&gt;Proof-Carrying Data&lt;/a&gt; and many more. In a private Ethereum network, it even becomes a non-issue, with the ability to introduce new precompiles.&lt;/p&gt;

&lt;p&gt;Also, there are proposals to decrease the amount of gas, which will improve this situation.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The glue component in the tax proof requires the use of hashes in ZoKrates. We have made efforts to integrate efficient external circuits and are hoping to collaborate with the ZoKrates team to make more integration possibilities a reality.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, we’ve seen an end-to-end zero-knowledge system to allow real-time taxation with exposing the user’s private data. This is just scratching the surface of the possibilities of practically using zero-knowledge proofs and other privacy preserving tools, in which we specialize in QED‐it.&lt;/p&gt;

&lt;p&gt;Of course, many technical details have been omitted for brevity, and there’s much more to the story. I invite you to write to us at &lt;a href=&quot;mailto:info@qed-it.com&quot;&gt;info@qed-it.com&lt;/a&gt; to learn more about the SDK.&lt;/p&gt;

&lt;p&gt;If you’re attending &lt;a href=&quot;https://z.cash.foundation/zcon/&quot;&gt;ZCon0&lt;/a&gt;, you’re welcome to meet some of our team and attend our CEO’s talk about “Zero Knowledge In The Enterprise” on day 2 at 9:10AM and the ZKProof workshop on the same day at 1PM, lead by our Daniel Benarroch and Eran Tromer.&lt;/p&gt;

&lt;p&gt;We are also &lt;a href=&quot;https://qed-it.com/jobs/&quot;&gt;hiring&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;I hope this has been enjoyable, and that it ignites the imagination as to what is now possible in a privacy preserving world!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">At QED‐it, we have a mission to provide privacy preserving systems for the enterprise. For the last two years, we’ve worked on many projects, developing complex SNARK circuits and higher level protocols to tackle different use-cases - asset management, supply chain, real-time risk assessment, predictive maintenance, credit scoring and more. We are happy to present one such project that has been done in collaboration with Deloitte. The project has been in the works for the last few months, in which the team in Deloitte utilized the QED‐it SDK to deploy a Zero-Knowledge Blockchain for their chosen use-case — new french tax rules presented in 2018.</summary></entry><entry><title type="html">Cryptocurrency recovery (or “What the BIP is all of this?”)</title><link href="/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this.html" rel="alternate" type="text/html" title="Cryptocurrency recovery (or “What the BIP is all of this?”)" /><published>2017-12-10T00:00:00+02:00</published><updated>2017-12-10T00:00:00+02:00</updated><id>/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this</id><content type="html" xml:base="/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this.html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;TL; DR&lt;/h2&gt;
&lt;h3 id=&quot;what-i-can-help-with&quot;&gt;What I can help with&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Got any type of coin stuck for which you saved some backup and want to consult whether they can be rescued? Contact me - &lt;a href=&quot;mailto:kobigurk@gmail.com&quot;&gt;kobigurk@gmail.com&lt;/a&gt;!&lt;/li&gt;
  &lt;li&gt;Want me to walk you through the recovery process? Gladly!&lt;/li&gt;
  &lt;li&gt;Want to consult how to properly backup your private keys in order to be able to recover your coins in the future? Contact me :-)
    &lt;h3 id=&quot;how-to-recover-by-yourself&quot;&gt;How to recover by yourself&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in an address whose private key you have? Use &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in an Electrum wallet whose 24 words seed you saved? Use the &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;BIP39 tool&lt;/a&gt; to derive the private keys and then use &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Got Bitcoins stuck in a Ledger Nano S who was destroyed but you have the 24 words saved? Import them into Electrum&lt;/li&gt;
  &lt;li&gt;Got any type of coin stuck in a Ledger Nano S who was destroyed but you have the 24 words saved? Use the &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;BIP39 tool&lt;/a&gt; to get your private keys and use their respective wallets to import them&lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in a multi-sig address in Electrum/Copay/anything, but have access to your Bitcoins? It’s a bit more complex, but possible - read through the deep dive or contact me - I can help!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Want to know more about the technical details? Keep reading.&lt;/p&gt;

&lt;h1 id=&quot;deep-dive&quot;&gt;Deep dive&lt;/h1&gt;
&lt;p&gt;Having Bitcoins is nice and having them being stored securely is even nicer. Though, as often is the case, the additional security often invites complexity to frequent use of your money. There are great software and hardware solutions that make your money safer than ever.&lt;/p&gt;

&lt;p&gt;What’s nice about these solutions is that they hide the complexity of securing your money and give you the best-practice approach to do it. The problem is that they deal with the specific use-case they had in mind and are less flexible when you’d like to deviate a bit from the usual path.&lt;/p&gt;

&lt;p&gt;For example, let’s say you use &lt;a href=&quot;http://docs.electrum.org/en/latest/2fa.html&quot;&gt;Electrum 2FA (Two-Factor Authentication)&lt;/a&gt;. It’s a great solution that uses &lt;a href=&quot;https://api.trustedcoin.com&quot;&gt;TrustedCoin&lt;/a&gt; as a co-signer to each of your transactions. Quoting from them,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;With a two-factor setup, your computer cannot spend your bitcoins without your entering a code from your cell phone. You will have significantly increased security.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That’s great! And there’s also a backup key that allows you to recover your Bitcoins in case TrustedCoin ever goes offline, so you’re safe. But…&lt;/p&gt;

&lt;p&gt;Recently some forks in Bitcoin happened. There’s Bitcoin Cash, Bitcoin Gold and maybe some more precious metal variants in the near-future. Those variants operate on a different chain than the usual Bitcoin, and that means that Electrum and TrustedCoin do not support it.&lt;/p&gt;

&lt;p&gt;Damn.&lt;/p&gt;

&lt;p&gt;If both my wallet and the co-signing service do not support Bitcoin Gold… I’m stuck! They hid all the complexity of how they secured me and now I don’t know how to recover.&lt;/p&gt;

&lt;p&gt;That was just an example of a situation that can happen in many other use-cases - hardware wallets (such as &lt;a href=&quot;https://www.ledgerwallet.com/r/6a0a?path=/products/ledger-nano-s&quot;&gt;Ledger Nano S&lt;/a&gt; which I absolutely recommend), multi-sig wallets such as &lt;a href=&quot;https://copay.io/&quot;&gt;Copay&lt;/a&gt; and others.&lt;/p&gt;

&lt;p&gt;It’s important to stress that usually the developers of the different platforms are doing an awesome job - they give you all the necessary bits of data that enable recovery. What they don’t do, understandably, is supporting every different recovery method that a user would like to have.&lt;/p&gt;

&lt;p&gt;For example, if your Ledger Nano S hardware wallet is destroyed because you were trading while taking a bath, the main recommendation is to buy a new one and use the “seed words” you were given when you created your wallet. That’s great, but what if Ledger goes bankrupt? I have to rummage through ebay to find rare Ledgers? Meh.&lt;/p&gt;

&lt;p&gt;How to store Bitcoins securely is a different matter I won’t get into right now, but I want to tell you some &lt;strong&gt;good news&lt;/strong&gt;: most of the wallets I mentioned here and many others use similar methods to store your coins, and that means that most of the steps of recovery are the same.&lt;/p&gt;

&lt;p&gt;In this post I will survey the preliminaries to understand how wallets store your Bitcoins (and other coins) using a single seed, how you would recover your Bitcoins in case you decide (or can) not to use a specific service anymore and what is the backup data you should keep in order to facilitate that.&lt;/p&gt;

&lt;h1 id=&quot;preliminaries&quot;&gt;Preliminaries&lt;/h1&gt;
&lt;p&gt;Bitcoin development happens through BIPs. These are Bitcoin Improvement Proposals. They are announced on the mailing list and assigned a number. Roughly, if there’s strong support behind it, it’s implemented in Bitcoin clients.&lt;/p&gt;

&lt;p&gt;Following is a high-level description of some of the BIPs that support the mechanism with which different wallets manage private keys.&lt;/p&gt;

&lt;h2 id=&quot;bip32&quot;&gt;BIP32&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot;&gt;BIP32&lt;/a&gt; describes a standard way to generate multiple addresses and private keys from a single private key, in a secure way. The exact technical details can be read in the BIP itself, but I’ll highlight the ones I feel important:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A parent (extended) private key can generate many distinct children private keys by an index.&lt;/li&gt;
  &lt;li&gt;The derivation can be done in a “normal” way or a hardened way, where a significant security difference exists - in the normal way, it’s possible (with some additional meta-data) to retrieve the parent private key from a child private key, but you gain an interesting feature - given the parent &lt;strong&gt;public&lt;/strong&gt; key, you can view all of its normal children public keys and, for example, monitor their balance.&lt;/li&gt;
  &lt;li&gt;The way you represent this derivation is by a &lt;strong&gt;path&lt;/strong&gt; - something like “m/0’/0”. This path means - take the (extended) private key, take its hardened child 0 and then from that resulting private key take the normal child 0 - and then you gain a private key you can use.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In drawings it looks like this:
&lt;img src=&quot;/content/images/2017/12/SoWkIImgAStDuSfLqBLJC53dKZ9GLm8pkHnIyrA0CW00.png&quot; alt=&quot;path&quot; /&gt;
translates to
&lt;img src=&quot;/content/images/2017/12/Untitled.png&quot; alt=&quot;path translated&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bip39&quot;&gt;BIP39&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki&quot;&gt;BIP39&lt;/a&gt; describes a standard way to generate a private key from a sequence of human-readable words.&lt;/p&gt;

&lt;p&gt;From the user’s perspective, she has a Mnemonic Sentence - a sequence of &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md&quot;&gt;words&lt;/a&gt; from which a binary array is derived. The exact number of words is related to the amount of entropy which translates to the level of security. Ledger Nano S, for example, uses a 24 word sequence.&lt;/p&gt;

&lt;p&gt;There’s an awesome &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;tool&lt;/a&gt; by &lt;a href=&quot;https://github.com/iancoleman&quot;&gt;Ian Coleman&lt;/a&gt; that allows you to generate the master private key given your mnemonic sentence, and following that, the children private keys derived from that. You can even run this tool offline by either compiling it yourself, or saving the html and running it on an offline computer.&lt;/p&gt;

&lt;h2 id=&quot;bip44&quot;&gt;BIP44&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki&quot;&gt;BIP44&lt;/a&gt; uses BIP32 and describes a standard way to generate private keys such that you can use the same master private key for different cryptocurrencies or use-cases without risk.&lt;/p&gt;

&lt;p&gt;That is, it standardizes the path that is used by BIP32:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m / purpose' / coin_type' / account' / change / address_index
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;purpose - constant &lt;strong&gt;44’&lt;/strong&gt;, to signify that this is a BIP44-compatible derivation.&lt;/li&gt;
  &lt;li&gt;coin_type - different coins have different numeric types. Bitcoin is 0 and there seems to be consensus that Ethereum is 60, Litecoin is 2 and many others. Ian Coleman’s tool has an extensive list of these, but a wallet doesn’t have to conform to it - the coin type is just a convention.&lt;/li&gt;
  &lt;li&gt;account - maybe you are managing wallets for different users or purposes. This element in the path allows you to distinguish them by assigning different indices to them.&lt;/li&gt;
  &lt;li&gt;change - is this an address that receive money, or a change addresses that just received change resulting from money I sent to someone? Can be 0 or 1.&lt;/li&gt;
  &lt;li&gt;address_index - the index of the address in this account, because you’re using a new address in each transaction when possible… I hope!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The literal meaning is - you take the master private key, you go to the purpose-indexed hardened child, the coin_type-indexed hardened child of it, the account-indexed hardened child of that, the change-indexed normal child of this and finally the address_index-indexed normal child of those.&lt;/p&gt;

&lt;h2 id=&quot;bip16&quot;&gt;BIP16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP16&lt;/a&gt; is a bit more complex to describe in a few words that also convey the motivation, but I’ll try - it describes a general way to encode complex scripts in a way that’s compatible with single-address schemes and moves the burden of paying the fee for these complex scripts from the sender to the receiver.&lt;/p&gt;

&lt;p&gt;Such a complex script can be M-out-of-N multi-sig - an address from which you can only spend using M signatures out of N parties involved. This mechanism is used, for example, in Electrum 2FA, with a 2-out-of-3 multi-sig.&lt;/p&gt;

&lt;p&gt;Bitcoin’s scripting language is rich and I gave a talk on how it works and other interesting scripts you can use in the &lt;a href=&quot;https://drive.google.com/open?id=0B-EU9txb0XfwYkE1eFFVLW1tLU0&quot;&gt;BlockchainWTB conference&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;recovery&quot;&gt;Recovery&lt;/h1&gt;
&lt;h2 id=&quot;types-of-addresses&quot;&gt;Types of addresses&lt;/h2&gt;
&lt;p&gt;Now we’re getting to the juicy stuff! We now know all the ingredients we need to recover from many different situation and I’m to describe some of these through concrete examples.&lt;/p&gt;

&lt;h3 id=&quot;p2pkh-regular-addresses&quot;&gt;P2PKH (regular addresses)&lt;/h3&gt;
&lt;p&gt;When you use your new Ledger Nano S for the first time, it walks you through a setup process. In this process, you are presented with a mnemonic sentence of 24 words.&lt;/p&gt;

&lt;p&gt;Now you know that these words actually generate a master private key for your Ledger using BIP39.&lt;/p&gt;

&lt;p&gt;When you use your different wallet in the chrome apps that Ledger supplies you with, you are actually using the same master private key but with different coin types, account indices and address indices, as specified in BIP44.&lt;/p&gt;

&lt;p&gt;Even more, the awesome guys at Ledger give you the option to see the exact path to your addresses - just go to your account settings in one of the wallet apps, and you will see a path that looks like a BIP44 path - “m/44’/0’/0”.&lt;/p&gt;

&lt;p&gt;So, if you want to recover from situation where Ledger doesn’t work anymore, you could import it into Electrum, for example.&lt;/p&gt;

&lt;p&gt;Let’s assume, though, you’d like to know for 100% you don’t depend on any single wallet software to exist anymore - you can use the BIP39 tool and see the private keys there and generate transactions using these private keys using any Bitcoin wallet you’d like. That can be &lt;a href=&quot;https://bitcoin.org/en/download&quot;&gt;Bitcoin Core&lt;/a&gt; or even a Bitcoin library such as &lt;a href=&quot;https://bitcoinjs.org/&quot;&gt;BitcoinJS&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;p2sh-multi-sig&quot;&gt;P2SH (multi-sig)&lt;/h3&gt;
&lt;p&gt;P2SH is BIP16 - roughly, the method to use complex scripts such as multi-sig, as used by Electrum 2FA, Copay and others.&lt;/p&gt;

&lt;p&gt;Recovering from a multi-sig wallet service going offline is a bit more complex, but it’s still possible.&lt;/p&gt;

&lt;p&gt;Let’s examine a 2-out-of-3 multi-sig Bitcoin wallet case. In this case, the address is derived from the &lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;public&lt;/strong&gt; keys of the different participants. Let’s assume we have these:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A primary key which you own and use in the usual transactions&lt;/li&gt;
  &lt;li&gt;a backup key which you store offline&lt;/li&gt;
  &lt;li&gt;the key of a wallet protection service, such as TrustedCoin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To transact from this address, you’d have to sign the transaction using &lt;strong&gt;2&lt;/strong&gt; of the &lt;strong&gt;private&lt;/strong&gt; keys. In this case, you’d usually use your primary one and the wallet protection service would provide the second signature. In case the wallet protection service goes offline, you’d use your primary and backup key.&lt;/p&gt;

&lt;p&gt;The thing is, that in order to transact from a P2SH address you don’t need just the 2 private keys, but also a &lt;strong&gt;redeem script&lt;/strong&gt; derived from the 3 public keys. That means, that in order to successfully recover, you also need this redeem script. So make sure you save that as well.&lt;/p&gt;

&lt;h2 id=&quot;ok-fine-how-to-actually-do-it&quot;&gt;OK, fine… How to actually do it?&lt;/h2&gt;
&lt;p&gt;For normal addresses, an ideal recovery software would roughly do this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use BIP39 with your seed words to recover your master private key&lt;/li&gt;
  &lt;li&gt;Collect the unspent outputs of the address you want to spend from - these are the Bitcoins you’ll send&lt;/li&gt;
  &lt;li&gt;Sign a transaction that sends money from this address to a destination address for your choosing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An example of such tool that automates a lot of this process in the case of Bitcoin Cash and Bitcoin Gold forks is &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt; by Nadav Ivgi.&lt;/p&gt;

&lt;p&gt;For P2SH addresses, you’d have to do the same, but when you sign the transaction, you’d provide multiple private keys and the redeem script. This redeem script is easily attainable in good wallets such as Electrum. I had such a case and wrote some code that uses exactly this redeem script to extract Bitcoin Gold using BitcoinJS.&lt;/p&gt;

&lt;p&gt;For other types of coins that use this scheme the recovery process is similar in theory, but it usually requires a different set of libraries and wallet software. For instance, in Ethereum, you may use &lt;a href=&quot;myetherwallet.com&quot;&gt;MyEtherWallet&lt;/a&gt; with the derived private keys.&lt;/p&gt;

&lt;p&gt;If you have some stuck Zcash, you may notice that the BIP39 tool misses it. That’s actually because of a technical limitation in BitcoinJS - Zcash use an address prefix which is 2 bytes, but BitcoinJS only supports a single-byte address prefixes. I have a hacky-fix from it that I use, but it’s not generic enough to publish.&lt;/p&gt;

&lt;p&gt;For some coins (such as Bitcoin Gold), there are also some wallets that supports the import of single-address private keys, but are not open-source. That doesn’t immediately mean the wallet developers are malicious, but it bugs me to use something proprietary like this for sensitive matters like money.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this post would encourage people to take advantage of the best security practices, such as using a hardware wallet or multi-sig.&lt;/p&gt;

&lt;p&gt;In this latest price surge, a lot of new folks come in, techie or otherwise, and are worried of using complex software, but using the easier-to-use ones (such as hardware wallets) feels like being dependent on a specific piece of software. It might feel like you’re losing control of your coins, contrary to the promise of cryptocurrencies.&lt;/p&gt;

&lt;p&gt;I hope this post showed you that you’re not actually strongly tied to it - you could always recover from it, given you that you backed up your private keys, or your seed, and required metadata (such as redeem scripts). You can do it yourself or the help of your friendly techier Bitcoiner friend.&lt;/p&gt;

&lt;p&gt;There are, of course, other recovery cases which I didn’t cover - such as wallets and coins that don’t use these schemes and other types of coins which require special handling.&lt;/p&gt;

&lt;p&gt;To wrap it up, I’d want you to feel free to reach out to me (&lt;a href=&quot;mailto:kobigurk@gmail.com&quot;&gt;kobigurk@gmail.com&lt;/a&gt; or @kobigurk on Twitter) if you have any stuck coins you’d like help with, would like to consult about backing up enough data to be able to recover in the future or wondering about the deeper technical details of how all of this works.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Having Bitcoins is nice and having them being stored securely is even nicer. Though, as often is the case, the additional security often invites complexity to frequent use of your money. There are great software and hardware solutions that make your money safer than ever. But it's not always easy to recover.</summary></entry><entry><title type="html">Phishing in the age of preview</title><link href="/2017/04/07/phising-preview.html" rel="alternate" type="text/html" title="Phishing in the age of preview" /><published>2017-04-07T00:00:00+03:00</published><updated>2017-04-07T00:00:00+03:00</updated><id>/2017/04/07/phising-preview</id><content type="html" xml:base="/2017/04/07/phising-preview.html">&lt;p&gt;Link previews are convenient. Implemented inside messaging platforms, they allow you to see the summary of a link a friend sent you without actually opening it, giving you the ability to decide whether it’s important or interesting enough to open it in a browser.&lt;/p&gt;

&lt;p&gt;Consider the following situation: Your WhatsApp account has been hacked. The hacker goes through your contacts list and message history, finding out who are your the people you’re conversing with the most. Then, the hacker prepares a malicious web-site - the web-site installs some malware that steals your bank account password once you go into it. The hacker even makes the web-site have a nice preview about a subject you’re discussing with your friend often, so your friend would think it’s a legitimate web-site. The friend, not knowing he’s talking with a hacker rather than his good friend, opens the link and gets infected!&lt;/p&gt;

&lt;p&gt;This may sound unrealistic - a messaging account getting hacked, but it happened to a colleague of mine in &lt;a href=&quot;http://qed-it.com&quot;&gt;QED-it&lt;/a&gt;. His Skype account got hacked and started distributing suspicious links to some of his contacts. Apparently, it was quite successful, as some of these contacts got hacked as well and sent him suspicious links back.&lt;/p&gt;

&lt;p&gt;So while it’s a multi-step phishing attack, once you get hold of a social media or messaging account, if you can construct believable links, it should be pretty easy to infect your contacts.&lt;/p&gt;

&lt;p&gt;#Wait, what?&lt;/p&gt;

&lt;p&gt;You must think - “well, this guy is crazy, it’s not that easy creating these links”. Is it really that easy to construct believable previews? Apparently yes! All you have to do is implement the &lt;a href=&quot;http://ogp.me/&quot;&gt;Open Graph Protocol&lt;/a&gt; on your web-page. This is a description of the Open Graph protocol, in their words:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Many of the messaging platforms support it - an incomplete list includes Facebook, WhatsApp and Telegram.&lt;/p&gt;

&lt;p&gt;In order to have a preview for your web-site, you just need to add this prefix to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html&lt;/code&gt; tag and these properties to your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; section:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;html prefix=&quot;og: http://ogp.me/ns#&quot;&amp;gt;
    &amp;lt;head&amp;gt; 
        &amp;lt;meta property=&quot;og:title&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:site_name&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:image&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:url&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:description&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That’s it. The hacker can now insert whatever code he wants, even a redirect to another web-site.&lt;/p&gt;

&lt;p&gt;Another component which may be useful in order to mask the fact it’s a malicious URL would be a URL shortener such as &lt;a href=&quot;http://bit.ly&quot;&gt;bit.ly&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#Meh, that’s a bit of work
Well, then you can just use &lt;a href=&quot;http://roll.kobi.one/generator.html&quot;&gt;my tool&lt;/a&gt; to generate an auto-redirecting malicious URL shortened by bit.ly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2017/04/Untitled.png&quot; alt=&quot;TPaaS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, that’s really easy…&lt;/p&gt;

&lt;p&gt;This, &lt;a href=&quot;http://bit.ly/2oCoEeY&quot;&gt;http://bit.ly/2oCoEeY&lt;/a&gt; , is a link that has a preview exactly like a real BBC article, but actually rick-rolls you (advantage if you like Rick Astley music videos!). This is its preview as it’s rendered on Telegram:
&lt;img src=&quot;/content/images/2017/04/Untitled-1.png&quot; alt=&quot;TelegramExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;#What can we do?
Good question. It’s always an interactive game - put a barrier, hackers get through and so on. But, in my feeling, there’s a lot of room for improvement regarding these previews.&lt;/p&gt;

&lt;p&gt;Facebook, for example, does a better job than the rest:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If a URL is given in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;og:url&lt;/code&gt; tag, that one is eventually used to retrieve the others.&lt;/li&gt;
  &lt;li&gt;If a URL is not given or invalid, then the actual URL is displayed under the post.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Telegram and WhatsApp, this is not the case - you completely control the content that is shown to the user.&lt;/p&gt;

&lt;p&gt;So, to begin with, sites can show the actual URL being used to retrieve the tags.&lt;/p&gt;

&lt;p&gt;A different direction I’ve been considering is similar to the HTTPS user experience existing in most major browsers:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the URL is not authenticated (HTTP), show a message that says “this preview is not secure”.&lt;/li&gt;
  &lt;li&gt;If the URL is from an HTTPS link, show the Common Name in the certificate.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These details alone would make the situation much better.&lt;/p&gt;

&lt;p&gt;#To summarize…
Link previews are nice and fun, but may also be used as a convenient tool to improve phishing campaigns considerably. I believe there are solutions to make it better and some platforms are realizing this and taking steps, but there’s more work to do.&lt;/p&gt;

&lt;p&gt;Hopefully we can combine the easiness and convenience with security!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Link previews are convenient. Implemented inside messaging platforms, they allow you to see the summary of a link a friend sent you without actually opening it, giving you the ability to decide whether it’s important or interesting enough to open it in a browser.</summary></entry></feed>
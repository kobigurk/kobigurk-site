<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-07-15T18:26:40+03:00</updated><id>/feed.xml</id><entry><title type="html">StarDrop - anonymous rewards on StarkNet</title><link href="/2021/07/14/stardrop.html" rel="alternate" type="text/html" title="StarDrop - anonymous rewards on StarkNet" /><published>2021-07-14T00:00:00+03:00</published><updated>2021-07-14T00:00:00+03:00</updated><id>/2021/07/14/stardrop</id><content type="html" xml:base="/2021/07/14/stardrop.html">&lt;p&gt;This post is about an experimental project to distribute rewards in a privacy-preserving manner running on StarkNet.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Blockchain projects seek to reward community members who perform activities that are beneficial to the network.&lt;/p&gt;

&lt;p&gt;For example, technical users participating in a test network for a project might get a few tokens in return for their participation. Another example includes users reteweeting a few tweets posted by the project.&lt;/p&gt;

&lt;p&gt;This brings up a privacy problem. In contrast to normal pseudonymous transactions, these rewards usually require some form of Know Your Customer procedure, even if it‚Äôs just a twitter handle. From this, it follows that the project awarding the tokens, or in some cases anyone, can track the user‚Äôs activity after receiving the reward.&lt;/p&gt;

&lt;p&gt;We can do better!&lt;/p&gt;

&lt;p&gt;StarDrop allows users in a group to claim a reward allocated to them, without the network or the project learning a link between the claims and the users. It uses techniques adapted from &lt;a href=&quot;https://privacypass.github.io/&quot; target=&quot;_blank&quot;&gt;Privacy Pass&lt;/a&gt; to build a Verifiable Oblivious Pseudo Random Function.&lt;/p&gt;

&lt;p&gt;The result is a system allowing a project to blindly sign a token that the user can use to redeem a reward later. Moreover, it does so in an on-chain zkrollup, StarkNet, allowing to do this verifiable in scale in low cost, as is appropriate for rewards that are usually not large.&lt;/p&gt;

&lt;p&gt;Disclaimer - I‚Äôve created this project mostly to learn and experiment with StarkNet and should not be used in production!&lt;/p&gt;

&lt;h1 id=&quot;privacy-pass&quot;&gt;Privacy Pass&lt;/h1&gt;

&lt;p&gt;Let‚Äôs first describe a sketch of a simplified version of Privacy Pass that we‚Äôll use to build our protocol. In general, Privacy Pass is a 2-party protocol allowing a user to create a blinded token, that a server will sign after performing their checks, and the user afterwards unblinding the signed token and being able to use it without the server learning which token belonged to which user. For a more in-depth description, check out &lt;a href=&quot;https://kobi.one/2019/01/05/exploring-privacypass.html&quot; target=&quot;_blank&quot;&gt;my post about Privacy Pass&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A user generates a token \(t\), which is a string of their choice.&lt;/li&gt;
  &lt;li&gt;The user then hashes it to a curve \(H(t)\), resulting in an element of a specific elliptic curve.&lt;/li&gt;
  &lt;li&gt;The user chooses a random blinding factor \(b\) and computes \(T=bH(t)\).&lt;/li&gt;
  &lt;li&gt;The user then sends \(T\) to the server.&lt;/li&gt;
  &lt;li&gt;The server uses their private key \(s\), having public key \(P=sG\) where \(G\) is a known generator of the curve, and sign the token, resulting in \(S=sT\). The server provides a proof that \(S\) and \(T\) have the same ratio as \(P\) and \(G\), proving that \(S\) is a valid signed token.&lt;/li&gt;
  &lt;li&gt;The user verifiers the proof and then unblinds it using the inverse of their blinding factor, resulting in \(R=b^{-1}S=b^{-1}sT=b^{-1}sbH(t)=sH(t)\). Notice that this is still a signed token, just without the blinding factor.&lt;/li&gt;
  &lt;li&gt;The user can then use the signed token \(R\) to redeem their reward. They do it by sending \(t\) and \(R\) to the server.&lt;/li&gt;
  &lt;li&gt;The server then computes by itself \(sH(t)\), and checks if it equals to \(R\). If it does, it proves that the user possessed a signed token, as they could not have produced \(R\) from \(t\) by themselves.&lt;/li&gt;
  &lt;li&gt;If successful, the server saves \(t\) as have been redeemed, so it could not be redeemed again.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that the original Privacy Pass construction uses an HMAC here, but this detail is not important in our case.&lt;/p&gt;

&lt;h2 id=&quot;stardrops-adaptations&quot;&gt;StarDrop‚Äôs adaptations&lt;/h2&gt;

&lt;p&gt;In our case, we‚Äôd like to allow users to claim their rewards on-chain, and so there isn‚Äôt a server we would claim the rewards against. There is only a smart contract. Therefore we have to adapt the protocol in step 7.&lt;/p&gt;

&lt;p&gt;One immediate thought is to put the private key \(s\) in the contract. That doesn‚Äôt directly work, since if the key is in the contract then anyone can create their own signed tokens.&lt;/p&gt;

&lt;p&gt;Building on that idea, we adapt the protocol to have three phases: commitment phase, key submission phase, redeem phase.&lt;/p&gt;

&lt;p&gt;In the commitment phase, users submit their signed tokens \(R\). In the key submission phase, the server submits their key \(s\) to the contract. New tokens will not be accepted anymore. In the redeem phase, users can submit \(t\) and match it with an \(R\) submitted in the commitment phase. This prevents users from using the published key \(s\) to create new tokens.&lt;/p&gt;

&lt;p&gt;There is another problem which we‚Äôll need to handle - front-running. Since now redeeming is all done on-chain, a malicious actor can see the activity a user performs with the contract and front-run both the commitment and the redeem phases. A clever user may notice it, but maybe not. There‚Äôs an easy way to prevent it though. Make token \(t\) be a public key, to which the user holds the private key. Then, when redeeming, the contract will verify a signature by that public key. The only thing a front-runner can now do is denial-of-service, but they can‚Äôt steal a user‚Äôs token.&lt;/p&gt;

&lt;p&gt;The protocol now looks as follows.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Initialize the contract with an operator and empty commitment mapping \(C\) and redeem mapping \(D\), and start with the commitment phase.&lt;/li&gt;
  &lt;li&gt;Users send their signed tokens \(R\) from a public key \(u\). The contract saves in the commitment mapping \(C[u]=R\).&lt;/li&gt;
  &lt;li&gt;The server then disables further sending of commitments, and moves to the key submission phase.&lt;/li&gt;
  &lt;li&gt;The server then submits its key \(s\).&lt;/li&gt;
  &lt;li&gt;The users now submit their tokens \(t\), of which the content is the public key \(u\), to the contract.&lt;/li&gt;
  &lt;li&gt;The contract computes \(sH(t)\), checks a signature by \(u\) on the redeem transaction, and checks whether \(C[u]=sH(t)\).&lt;/li&gt;
  &lt;li&gt;If successful, the contract transfers the reward to the user‚Äôs public key \(u\).&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;starknet&quot;&gt;StarkNet&lt;/h1&gt;

&lt;p&gt;Now that we have designed StarDrop for an on-chain smart contract, and as a consequence to a zkrollup, we can move on to implement it in StarkNet!&lt;/p&gt;

&lt;p&gt;StarkNet is a zkrollup that allows writing smart contracts. This is in contrast to the original deployments of zkrollups that could perform only payments. In that manner, it is similar to zkSync aims to achieve.&lt;/p&gt;

&lt;p&gt;StarkNet works in a model where there‚Äôs an operator that executes the contracts and creates a proof for them. The user just provides the input. StarkNet uses Cairo under the hood, which is a language that compiles down to VM bytecode a STARK proof can created about.&lt;/p&gt;

&lt;p&gt;Cairo supports &lt;em&gt;hints&lt;/em&gt;, which are a way to provide precomputed inputs to a STARK to make the proof more efficient. These hints are computed using Python programs in Cairo. Running any Python code in StarkNet would then provide a denial-of-service vector against the operator, so StarkNet only allows specific methods to be used with hints, such as signature verification.&lt;/p&gt;

&lt;p&gt;Moreover, Cairo is a high level language. There are operations that are significantly more efficient if implemented directly in the low-level AIR representation of the program. Therefore, Cairo uses a few ‚Äúbuilt ins‚Äù, such as for performing a range check.&lt;/p&gt;

&lt;h1 id=&quot;implementation-of-stardrop-in-starknet&quot;&gt;Implementation of StarDrop in StarkNet&lt;/h1&gt;

&lt;h2 id=&quot;hash-to-curve&quot;&gt;Hash to curve&lt;/h2&gt;

&lt;p&gt;The hash \(H\) takes a string and outputs an element in the elliptic curve with an unknown discrete logarithm against other outputs of the hash. Ideally, it would behave as a good random oracle. Currently in StarkNet, the only hash efficiently available is a Pedersen hash, which does produce a point in the curve, but has algebraic properties that make it visibly different from a random oracle.&lt;/p&gt;

&lt;p&gt;Looking at a simplified version of a Pedersen hash, where the hash of \(b_0b_1\) is \(b_0G_1+b_1G_2\), we can give an example. Given the the hashes of \(01\) and \(10\), we can compute the hash of \(11\) without calling the hash function. This is true since \(H(01) = G_2\) and \(H(10) = G_1\), and so \(H(11) = H(01) + H(10) = G_1+G_2\).&lt;/p&gt;

&lt;p&gt;This would have to be improved before using this system securely.&lt;/p&gt;

&lt;h2 id=&quot;scalar-multiplication&quot;&gt;Scalar multiplication&lt;/h2&gt;

&lt;p&gt;Being limited to the type of code we can run, we soon stumble into a problem. Step 6 in our protocol requires us to perform a scalar multiplication, and we don‚Äôt have an efficient method to do it. Can we still do it? The answer is yes!&lt;/p&gt;

&lt;p&gt;An easy way is to implement &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Elliptic_curve_point_multiplication&quot; target=&quot;_blank&quot;&gt;affine addition and doubling formulas&lt;/a&gt;. For those coming directly from the SNARK world, this would seem problematic - these formulas have exceptions and conditionals are needed unless you can avoid the exceptions. All the branches in a SNARK are always executed, which can become expensive. This is not as big of an issue in StarkNet, since it runs the Cairo VM, and so the programming model is similar to a CPU, where you only pay forthe branch that is actually executing.&lt;/p&gt;

&lt;p&gt;An alternative exception-free approach would have been to implement &lt;a href=&quot;https://eprint.iacr.org/2015/1060.pdf&quot; target=&quot;_blank&quot;&gt;complete addition and doubling formulas&lt;/a&gt;, but that would likely be more expensive since the number of multiplications needed is larger.&lt;/p&gt;

&lt;p&gt;We‚Äôre still not done - in order to implement the ‚Äúdouble and add‚Äù method, we need the binary representation of the key. Usually I would do it by providing the binary representation as a hint and checking that when summing it with the relevant powers of 2 we get the scalar. Since we can‚Äôt use arbitrary hints, we ask the user to provide these hints when claiming the drop. We then check the representation is correct and solely composed of bits. Alternatively, we could ask the operator to provide the representation when submitting their key.&lt;/p&gt;

&lt;h2 id=&quot;contract-and-scripts&quot;&gt;Contract and scripts&lt;/h2&gt;

&lt;p&gt;StarDrop is implemented as a StarkNet contract and a collection of Python scripts. The operation is quite manual at this point, but it‚Äôs fully functional. The implementation is available at https://github.com/kobigurk/stardrop.&lt;/p&gt;

&lt;p&gt;The usual workflow looks like (including example invocations):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator initializes the contract using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initialize&lt;/code&gt; function:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function initialize --inputs 3582577746677722431740023720320633876956623133930419590527228763639578535453 1000 2&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users can now submit signed tokens to the contract. To obtain them, they use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blind.py&lt;/code&gt; to create a blinded requests and send it to the operator off-chain. Then the operator uses &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sign_token.py&lt;/code&gt; and send the signed blinded token and correctness proofs to the user. The user then runs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unblind.py&lt;/code&gt; to get the unblinded signed token and verify the correctness proofs. Finally, the user sends the commitment to the contract:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function commit --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954 3261967588085170658862293428587059222438269839015135942205506249609410833918 383622200922475827691447562161872358420401626548600386003465214370732507533 166731635083539346047790634754225714698968525453493336513299480525988223874&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator then ends the commitment phase using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end_commitment_phase.py&lt;/code&gt; and uses the resulting signature:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function end_commitment_phase --inputs 1572514341211381639146744466808246693800547744347028176296700256447030933678 1978481093464076802357781694214950813691007442586456313662641217350746463161&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The operator submits the key to the contract using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;submit_key.py&lt;/code&gt; and uses the resulting signature:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function submit_key --inputs 284697472624386009295839589936418945178 3224560532100339074740113102065711825633396413956247303725126014773482991514 2291167198440858938698896566523731692215085667023695658054610128415429789324&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Users can now claim their rewards by providing their public key and hints about operator‚Äôs key and the token:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet invoke --address $${ADDR} --abi contract_abi.json --function claim_drop --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954 1409864911388159352029816777278381225970523230642148213329717159060539927901 0 1 0 1 1 0 0 1 0 0 0 1 1 1 1 0 0 1 0 1 1 0 0 0 1 1 1 0 0 0 1 0 0 1 1 0 1 1 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 1 0 1 1 0 1 1 1 1 0 1 1 0 1 0 1 0 1 0 0 1 0 0 1 1 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 0 1 1 1 1 1 0 0 0 1 0 1 1 1 1 0 1 0 1 1 1 0 1 0 0 0 1 1 0 1 0 1 1&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;At this point, the user‚Äôs balance has increased and the pool‚Äôs balance has decreased. This can be checked:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet call --address $${ADDR} --abi contract_abi.json --function get_balance --inputs 2042536649993117364296625103999908576248412199423456520000316129072735862954&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;starknet call --address $${ADDR} --abi contract_abi.json --function get_pool_balance&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;StarkNet Planets, the currently deployed version of StarkNet, is already an expressive zkrollup and fits a lot of our needs, it has a few limitations. An important one is that it doesn‚Äôt support inter-contract communication in L2 or L1 ‚Üî L2 communication.&lt;/p&gt;

&lt;p&gt;This means that currently the contract can only track balances that users have internally and not actually transfer token that user can use. The changes needed to make that happen once it does support those are small.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;StarkNet‚Äôs programmability opens up interesting application possibilities and provides a lot of flexibility as to what can be implemented. The CLI tooling is easy to use and the developers and users don‚Äôt have to maintain any heavy machinery to create proof or use it. Furthermore, the VS code extension adds useful syntax highlighting.&lt;/p&gt;

&lt;p&gt;I did hit a few snags and additionally have some improvement suggestions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I managed to kill StarkNet testnet deployment! When using the built in methods, their import order makes a difference, and crashed the StarkNet operator when specified in the wrong order, causing it to stop producing blocks. Kudos to the team that fixed it promptly, and now reject contracts that use the wrong import order. This is reasonable for software in such an early stage and that‚Äôs what testnets are for üôÇ&lt;/li&gt;
  &lt;li&gt;The testing workflow is hard. This is because there‚Äôs no way to run a StarkNet operator or a simulator of it locally, and so you have to wait for it to process your requests, which can take several minutes. That said, if there are exceptions and not just logic errors, the StarkNet operator reports them early and doesn‚Äôt wait for the actual execution.&lt;/li&gt;
  &lt;li&gt;The Cairo syntax is sometimes overly verbose and sometimes overly implicit. For example, when using built ins, you have to explicitly specify whether a function uses it, but then they‚Äôre usually implicitly passed to underlying functions. This was also confusing to me when dealing with ‚Äúrevoked references‚Äù, having to localize the implicitly passed built ins to prevent that from happening, per Lior‚Äôs advice.&lt;/li&gt;
  &lt;li&gt;Exceptions and asserts can occur at any time and it‚Äôs unclear whether an underlying function is safe to call with unchecked inputs. To be fair, this is a problem with most ZKP languages today.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall the experience was great, and I‚Äôm looking forward for the next versions!&lt;/p&gt;

&lt;h1 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h1&gt;

&lt;p&gt;I thank Louis, Tom and Lior a lot for answering my questions when working on this experiment.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">This post is about an experimental project to distribute rewards in a privacy-preserving manner running on StarkNet.</summary></entry><entry><title type="html">PLONK custom gates design considerations</title><link href="/2021/05/20/plonk-custom-gates.html" rel="alternate" type="text/html" title="PLONK custom gates design considerations" /><published>2021-05-20T00:00:00+03:00</published><updated>2021-05-20T00:00:00+03:00</updated><id>/2021/05/20/plonk-custom-gates</id><content type="html" xml:base="/2021/05/20/plonk-custom-gates.html">&lt;p&gt;Thanks to Zac Williamson and Kev for explaining ideas that helped form this document. Thanks to Han for spotting a mistake in ‚ÄúApproach 2‚Äù of the MiMC custom gate that could lead to breaking soundness.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;PLONK has flexible arithmetization, and can quite easily express complex polynomial gates. ‚ÄúBasic PLONK‚Äù, as defined in the &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;paper&lt;/a&gt;, defines only fan-in 2 arithmetic gates. The purpose of this document is to show what are custom gates and how they affect the performance of a PLONK proof.&lt;/p&gt;

&lt;p&gt;At a high level, PLONK defines the gates as part of a ‚Äúquotient polynomial‚Äù \(t(x)\) - if this polynomial is zero at the points that represents gates, then the constraint system is satisfied.&lt;/p&gt;

&lt;p&gt;The arithmetic gate contribution to the quotient polynomial is defined as:&lt;/p&gt;

\[a(X)b(X)q_M(X) + a(X)q_L(X) + b(X)q_R(X) + c(X)q_O(X) + PI(X) + q_C(X)\]

&lt;p&gt;For example, a multiplication gate that calculates \(xy = z\) is going to have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
\[a(g^i) = x\]
  &lt;/li&gt;
  &lt;li&gt;
\[b(g^i) = y\]
  &lt;/li&gt;
  &lt;li&gt;
\[c(g^i) = z\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_M(g^i) = 1\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_O(g^i) = -1\]
  &lt;/li&gt;
  &lt;li&gt;
\[q_L(g^i), q_R(g^i), PI(g^i), q_C(g^i) = 0\]
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;basic-plonk&quot;&gt;Basic PLONK&lt;/h1&gt;

&lt;p&gt;‚ÄúBasic PLONK‚Äù has the following performance characteristics:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Proof size of \(9\mathbb{G}_1\) + \(7\mathbb{F}\) arising from:
 a. Commitments to the wires polynomials \(a(x)\), \(b(x)\), \(c(x)\)
 b. Commitment to the permutation polynomial \(z(x)\)
 c. Commitments to 3 \(n-\)degree polynomials, components of the \(3n-\)degree quotient polynomial \(t(x)\)
 d. Commitment to the opening polynomial \(W_z(x)\), ensuring sure the evaluations of \(t(x), r(x), a(x), b(x), c(x), S_{\sigma_1}, S_{\sigma_2}\) are correct at \(z\)
 e. Commitment to the opening polynomial \(W_{zw}(x)\), ensuring the evaluation of \(z(x)\) is correct at \(zw\)&lt;/li&gt;
  &lt;li&gt;Proving complexity of:
 a. \(9n\) \(\mathbb{G}_1\) exponentiations resulting from computing commitments of polynomials of degree \(n\): 3 from 1a, 1 from 1b, 3 from 1c, 1 from 1d, 1 from 1e
 b. Roughly \(54n\) field operations from FFTs:
    &lt;ul&gt;
      &lt;li&gt;8 of degree \(4n\) from:
        &lt;ul&gt;
          &lt;li&gt;The contribution of the permutation argument - 3 for $$\sigma_{0,1,2}&lt;/li&gt;
          &lt;li&gt;1 for \(z\)&lt;/li&gt;
          &lt;li&gt;3 for the \(a, b, c\) wires polynomials&lt;/li&gt;
          &lt;li&gt;1 inverse transform for the quotient polynomial itself at degree \(4n\)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;6 of degree \(2n\) from:
        &lt;ul&gt;
          &lt;li&gt;The contribution of the arithmetic gate - \(q_M, q_L, q_R, q_O\) and \(q_C\)&lt;/li&gt;
          &lt;li&gt;1 inverse transform for the quotient polynomial itself at degree \(2n\)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;12 of degree \(n\) from:
        &lt;ul&gt;
          &lt;li&gt;12 inverse transforms on all the polynomials we need to perform FFT on&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Verification complexity of (discounting field operations and hashes):
    &lt;ul&gt;
      &lt;li&gt;18 exponentiations in \(\mathbb{G}_1\):
        &lt;ul&gt;
          &lt;li&gt;6 from the linearization polynomial opening:
            &lt;ul&gt;
              &lt;li&gt;5 from the arithmetic gate polynomials \(q_M, q_L, q_R, q_O\) and \(q_C\)&lt;/li&gt;
              &lt;li&gt;1 from the \(z\) polynomial&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;9 from the quotient polynomial opening:
            &lt;ul&gt;
              &lt;li&gt;3 from the \(n-\)degree parts of \(t\)&lt;/li&gt;
              &lt;li&gt;3 from the wire polynomials \(a, b\) and \(c\)&lt;/li&gt;
              &lt;li&gt;2 from the permutation polynomials \(s_{\sigma1}, s_{\sigma2}\)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;1 from the evaluation commitment - containing all the evaluations of the opened polynomials&lt;/li&gt;
          &lt;li&gt;1 from the polynomial commitment argument for evaluation at \(z\) - the random opening point&lt;/li&gt;
          &lt;li&gt;1 from the polynomial commitment argument for evaluation at \(zw\) - the random opening point + 1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given \(n\) being the number of arithmetic gates, basic PLONK has a quotient polynomial of degree \(3n\). The arithmetic gate part itself has only degree \(2n\), and the \(3n\) degree stems from the permutation argument on the wire polynomials.&lt;/p&gt;

&lt;h1 id=&quot;designing-a-custom-gate&quot;&gt;Designing a custom gate&lt;/h1&gt;

&lt;p&gt;When designing a custom gate, you can change multiple characteristics.&lt;/p&gt;

&lt;h2 id=&quot;existing-wires&quot;&gt;Existing wires&lt;/h2&gt;

&lt;p&gt;If you‚Äôre introducing a new polynomial gate on existing wires, you affect:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Quotient polynomial contribution, which defines the constraints the custom gate verifies&lt;/li&gt;
  &lt;li&gt;Linearization polynomial contribution, which defines a partially evaluated quotient polynomial contribution, such that the contribution doesn‚Äôt contain polynomial products of committed polynomials&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you increase the degree of the quotient polynomial, you will affect:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;lt; 3n\), then you pay in FFTs of degree \(2n\) on new selector polynomials, and if there‚Äôs a product of selector polynomials, then opening of some of them until you reach a linear polynomial&lt;/li&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;gt; 3n, \leq 4n\) (meaning the degree of the quotient polynomial is still \(\leq 3n\)), then you similarly pay in openings and FFTs become of degree \(4n\)&lt;/li&gt;
  &lt;li&gt;If the degree of the gate is \(&amp;gt; 4n\) and we still want to use the same fast-proving method, you pay in:
    &lt;ul&gt;
      &lt;li&gt;Similarly, in openings&lt;/li&gt;
      &lt;li&gt;FFTs of degree \(&amp;gt;4n\). E.g., if degree is \(5n\) and assuming radix-2 FFTs, then FFT of degree \(8n\)&lt;/li&gt;
      &lt;li&gt;Another commitment for every \(n-\)degree increase, making the proof larger by one group element and an additional scalar multiplication of size \(&amp;lt;=n\). Additionally, the verifier will pay a scalar multiplication for each \(n-\)degree increase&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Additionally, you pay a scalar multiplication in verification for each selector polynomial you introduce.&lt;/p&gt;

&lt;h2 id=&quot;adjacent-wires&quot;&gt;Adjacent wires&lt;/h2&gt;

&lt;p&gt;If you‚Äôre introducing adjacent wires (\(a_{i+1}, b_{i+1}, c_{i+1}\)), you need to add the opening of these values at \(zw\), so 1 additional field element for each of the required openings, but no significant increase in prover/verifier times - the prover needs to evaluate at the new points, and the verifier already has a polynomial commitment opening at \(zw\), so it folds into that&lt;/p&gt;

&lt;h2 id=&quot;further-wires&quot;&gt;Further wires&lt;/h2&gt;

&lt;p&gt;If you want access to more wires, e.g. \(a_{i+k}, b_{i+k}, c_{i+k}\), you similarly needs an opening at \(zw^{k}\), so 1 additionaly field element for each of the required openings. The prover similarly to the adjacent wires case needs to evaluate at additional points. There is another significant cost increase for both the prover and the verifier though - the prover needs to commit to the opening polynomial at \(zw^{k}\), which is another \(n-\)degree exponentiation and an additional group element in the proof, and the verifier has to open it, requiring an additional scalar multiplication.&lt;/p&gt;

&lt;h2 id=&quot;additional-wires&quot;&gt;Additional wires&lt;/h2&gt;

&lt;p&gt;If you‚Äôd like to introduce additional wires above \(a,b,c\), you could do it in multiple ways.&lt;/p&gt;

&lt;p&gt;One way is to introduce wires that are accessible throughout all the gates - introduce more \(n-\)degree polynomials, e.g. \(d(x), e(x)\) and so on. This would cause:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Increase of the permutation polynomial degree, causing the quotient polynomial degree to increase, and in turn increase the FFT degrees, a commitment and a scalar multiplication for each additional wire polynomial because of the \(n-\)degree increase in the quotient polynomial&lt;/li&gt;
  &lt;li&gt;An additional group element in the proof for each additional wire - a commitment to the wire polynomial&lt;/li&gt;
  &lt;li&gt;An additional field element in the proof for each additional wire - the evaluation of the corresponding \(S_{\sigma_i}\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Another way is to introduce wires that are accessible only for half of the gates, i.e. for the use in exotic gates.&lt;/p&gt;

&lt;p&gt;Zac wrote about it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The trick is to add a second verification equation for your basic plonk gates.

Split each degree-n A(X), B(X), C(X) into two degree n/2 polynomials A1(X), A2(X), B1(X), B2(X), C1(X), C2(X).

Also do this splitting process with the selector polynomials Qm(X), Ql(X), Qr(X), Qo(X), Qc(X).

In addition to the original plonk gate equation, add a second:

Qm2(X).A2(X).B2(X) + Ql2(X).A2(X) + Qr2(X).B2(X) + Qo2(X).C2(X) + Qc2(X) + 0 mod Z_H(X)

You can then add in additional verification equations for exotic gates with 6 wires.

Because the degrees of your polynomials are half what they used to be, prover compute times haven‚Äôt increased (2x the polynomials, but the degrees have been halved). 

The permutation check now operates on six witness polynomials instead of three - so the maximum degree of your quotient polynomial is still degree 3n.

This also gives you some extra wiggle room - your exotic 6-wire gate equation can be a degree-6 polynomial, without increasing the degree of the quotient polynomial

The trade off with all of this, is increased verification time and increased proof size - each new selector polynomial and each new wire commitment will add 1 scalar mul into the verification equations, which starts to add up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;example---mimc7&quot;&gt;Example - MiMC7&lt;/h1&gt;

&lt;p&gt;To calculate a MiMC7 round function for round \(i\), we need to calculate \((x+k+c_i)^7\), where \(x,k\) are inputs and \(c_i\) is a constant&lt;/p&gt;

&lt;h2 id=&quot;approach-1---using-arithmetic-gates&quot;&gt;Approach 1 - using arithmetic gates&lt;/h2&gt;

&lt;p&gt;We would define the following gates:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;An add gate to calculate \(t = x+k+c_i\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^2\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^3\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to calculate \(t^6\)&lt;/li&gt;
  &lt;li&gt;A multiplication gate to claculate \(t^7\)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In total, 5 constraints.&lt;/p&gt;

&lt;h2 id=&quot;approach-2---using-a-custom-gate-of-degree-7&quot;&gt;Approach 2 - using a custom gate of degree 7&lt;/h2&gt;

&lt;p&gt;We augment the quotient polynomial with the following contribution:&lt;/p&gt;

\[(c(x) - (a(x) + b(x) + q_{mc}(x))^7)q_{mimc}(x)\]

&lt;p&gt;This makes the quotient polynomial of degree \(7n\).&lt;/p&gt;

&lt;p&gt;Assuming we‚Äôre still using the fast-proving method, this adds 2 scalar multiplications for the verifier, for the two new selector gates. The verifier also pays by 4 additional scalar multiplications because of the 4 degree increase in the quotient polynomial.&lt;/p&gt;

&lt;p&gt;The proof becomes larger by 4 group elements.&lt;/p&gt;

&lt;h2 id=&quot;approach-3---using-a-custom-gate-of-degree-3-and-an-adjacent-wire&quot;&gt;Approach 3 - using a custom gate of degree 3 and an adjacent wire&lt;/h2&gt;

&lt;p&gt;We augment the quotient polynomial with the following contribution:&lt;/p&gt;

\[(((c(x) + a(x) + q_{mc}(x))^3 - b(x))\alpha + (c(x) + a(x) + q_{mc}(x)).b(x)^2 - c(xw) )\alpha^2)q_{mimc}(x)\]

&lt;p&gt;This gate works by verifying that \(b(x)\) contains the \(t^3\), and proceeds to put \(t^7\) in \(c_{i+1}\).&lt;/p&gt;

&lt;p&gt;The random \(alpha\) coefficients enforce that each individual term will be \(0\).&lt;/p&gt;

&lt;p&gt;This doesn‚Äôt increase the quotient polynomial degree, and thererfore proving times are similar - only a few more evaluations.&lt;/p&gt;

&lt;p&gt;We pay in:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;2 scalar multiplications by the verifier for the two new selectors \(q_{mc}(x), q_{mimc}(x)\)&lt;/li&gt;
  &lt;li&gt;Additional field element in the proof - \(c(zw)\)&lt;/li&gt;
  &lt;li&gt;Additional field element in the proof - \(q_{mc}(z)\)&lt;/li&gt;
  &lt;li&gt;We don‚Äôt pay in a field element for \(q_{mimc}(z)\) - it‚Äôs reflected in the linearizer&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We‚Äôve listed a few methods to use the flexibility of the arithmetization step and listed different trade-offs a custom gate designer can take, together with an example of a MiMC7 gate.&lt;/p&gt;

&lt;p&gt;We hope that this note proves useful for those learning and using custom gates.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Thanks to Zac Williamson and Kev for explaining ideas that helped form this document. Thanks to Han for spotting a mistake in ‚ÄúApproach 2‚Äù of the MiMC custom gate that could lead to breaking soundness.</summary></entry><entry><title type="html">Sapling audit</title><link href="/2019/01/31/sapling-audit.html" rel="alternate" type="text/html" title="Sapling audit" /><published>2019-01-31T00:00:00+02:00</published><updated>2019-01-31T00:00:00+02:00</updated><id>/2019/01/31/sapling-audit</id><content type="html" xml:base="/2019/01/31/sapling-audit.html">&lt;p&gt;Cross-posting from Medium, where we describe the audit we performed to Zcash Sapling. &lt;a href=&quot;https://medium.com/qed-it/sapling-audit-9b531be9d30&quot; target=&quot;_blank&quot;&gt;Check it out here.&lt;/a&gt;&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Cross-posting from Medium, where we describe the audit we performed to Zcash Sapling. Check it out here.</summary></entry><entry><title type="html">Exploring Privacy Pass</title><link href="/2019/01/05/exploring-privacypass.html" rel="alternate" type="text/html" title="Exploring Privacy Pass" /><published>2019-01-05T00:00:00+02:00</published><updated>2019-01-05T00:00:00+02:00</updated><id>/2019/01/05/exploring-privacypass</id><content type="html" xml:base="/2019/01/05/exploring-privacypass.html">&lt;p&gt;This post explores Privacy Pass, a protocol which ‚Äúlets users prove their identity across multiple sites anonymously without enabling tracking‚Äù. We will go through the protocol components and eventually see a &lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;fully-compatible implementation of Privacy Pass in Rust&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;privacy-in-the-internet&quot;&gt;Privacy in the internet&lt;/h2&gt;

&lt;p&gt;Privacy for users in the internet is often advocated for, and just as often, compromised. This happens for good reasons - creating social networks (i.e., Facebook), allowing smarter usage of our data (i.e., Gmail), convenience of usage (i.e., OAuth - ‚ÄúLogin using Google‚Äù), Security (i.e., Cloudflare‚Äôs HTTPS-for-every-site and Denial-of-Service protection) and many other reasons.&lt;/p&gt;

&lt;p&gt;The privacy loss is usually not absolute - it allows privacy against some adversaries. For example, while Facebook has access to your personal data, it takes the responsibility of not exposing it to other users, and does it pretty well.&lt;/p&gt;

&lt;p&gt;It makes me glad when these services which potentially compromise privacy also take additional steps to re-introduce it in creative ways.&lt;/p&gt;

&lt;h2 id=&quot;cloudflares-crypto-week&quot;&gt;Cloudflare‚Äôs Crypto Week&lt;/h2&gt;
&lt;p&gt;One of the companies whose trade-offs I like is Cloudflare. I‚Äôve been using their service for many years to easily introduce HTTPS to my websites without having to go through the usual complex processes of obtaining and managing an HTTPS certificate.&lt;/p&gt;

&lt;p&gt;A few weeks ago, Cloudflare had a &lt;a href=&quot;https://blog.cloudflare.com/tag/crypto-week/&quot; target=&quot;_blank&quot;&gt;Crypto Week&lt;/a&gt;, where each day they posted about newly-developed features, who use cryptography to improve their services, in aspects such as privacy.&lt;/p&gt;

&lt;p&gt;Although not part of the Crypto Week, this exposed me to a protocol Cloudflare supports since 2017 - &lt;a href=&quot;https://blog.cloudflare.com/cloudflare-supports-privacy-pass/&quot; target=&quot;_blank&quot;&gt;Privacy Pass&lt;/a&gt;. This protocol has been developed in collboration with academic researchers and is provided as a service by Cloudflare.&lt;/p&gt;

&lt;h2 id=&quot;privacy-pass&quot;&gt;Privacy Pass&lt;/h2&gt;

&lt;p&gt;The Privacy Pass protocol, &lt;a href=&quot;https://captcha.website/&quot; target=&quot;_blank&quot;&gt;as implemented in Cloudflare&lt;/a&gt;, attempts solving the following tension:&lt;/p&gt;

&lt;p&gt;Cloudflare would like to give access to websites to humans rather than, let‚Äôs say, mal-intentioned bots. To do that, Cloudflare requires users to solve a &lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot; target=&quot;_blank&quot;&gt;CAPTCHA&lt;/a&gt; when they have suspicion.
On the one hand, these challenges protect the websites - no non-humans may access the site. On the other hand, false-positives cause inconvenience to users. That puts the burden on Cloudflare to improve their human-detection capbalities without compromising on security too much.&lt;/p&gt;

&lt;p&gt;This is where Privacy Pass comes in. It allows a user to solve a CAPTCHA once and use this ‚Äúproof-of-humanity‚Äù later on.&lt;/p&gt;

&lt;h2 id=&quot;the-protocol&quot;&gt;The protocol&lt;/h2&gt;

&lt;p&gt;Rather than outlying the protocol directly, I‚Äôd like to build it step-by-step, to highlight the importance of each of the components in the protocol, and why stopping at that level might not be enough.&lt;/p&gt;

&lt;h3 id=&quot;methodology&quot;&gt;Methodology&lt;/h3&gt;

&lt;p&gt;Methodology-wise, I believe the best way to understand a topic is being able to teach it. In teaching, there are multiple levels. Two of these are teaching another human (outlying the theory, proofs, math) and teaching a machine (implementing it so it can be used).&lt;/p&gt;

&lt;p&gt;While teaching another human is highly valuable, some aspects are more readily exposed and understood when teaching a machine. This is one of the reasons I‚Äôve chosen to &lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;implement Privacy Pass in Rust&lt;/a&gt; - in this way I could see the nitty-gritty details of how Cloudflare and the researchers made Privacy Pass work in practice.&lt;/p&gt;

&lt;h3 id=&quot;detecting-a-human&quot;&gt;Detecting a human&lt;/h3&gt;

&lt;p&gt;Cloudflare uses CAPTCHAs to detect humans when suspicion arises. Essentially, Cloudflare presents a challenge with weird-looking letters and numbers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/captcha.jpg&quot; alt=&quot;CAPTCHA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The user then provides the solution to what they think is the solution. If Cloudflare approves it, they allow the user through.&lt;/p&gt;

&lt;p&gt;Recall that the goal of Privacy Pass is to carry this ‚Äúproof-of-humanity‚Äù to other situations where the user might be suspected.&lt;/p&gt;

&lt;p&gt;So why not, let‚Äôs say, when Cloudflare receives a correct solution, make Cloudflare send multiple ‚Äúpasses‚Äù which can be used in other sites?&lt;/p&gt;

&lt;p&gt;The answer lies in &lt;em&gt;tracking&lt;/em&gt;. When Cloudflare would send these passes to the user, they will know that these passes are related to the original CAPTCHA solution, and by so, to the original website where the user saw the challenge.&lt;/p&gt;

&lt;p&gt;If Cloudflare would have liked, they could track the user across multiple sites. To show a concrete example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, being at home, would have gone to kobi.one, see a challenge and solve it, let‚Äôs denote the solution \(S\). They would send the solution to Cloudflare, containing the solution \(S\) and natually their home IP.&lt;/li&gt;
  &lt;li&gt;Cloudflare would approve the solution, and send passes \(P_1, ... P_N\). Additionally, they would store in their database the connection between \(S\), each \(P_i\) and the user‚Äôs IP.&lt;/li&gt;
  &lt;li&gt;Next, when the user uses one of the passes in other websites, maybe from a coffee shop having a different IP, Cloudflare would be able to correlate the usage of pass \(P_i\) with the user.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cloudflare could obviously &lt;em&gt;not&lt;/em&gt; store this data, and that would require putting the trust in Cloudflare. While they might deserve it, you can do better.&lt;/p&gt;

&lt;h3 id=&quot;discerete-logarithm-problem&quot;&gt;Discerete Logarithm Problem&lt;/h3&gt;

&lt;p&gt;What if Cloudflare could provide the passes without being able to track their usage forward? Apparently, with some &lt;a href=&quot;http://en.wikipedia.org/wiki/Elliptic_curve_cryptography&quot; target=&quot;_blank&quot;&gt;elliptic-curve cryptography&lt;/a&gt;, it is possible.&lt;/p&gt;

&lt;p&gt;Without diving too much into elliptic-curves, I‚Äôll remind some basic facts.&lt;/p&gt;

&lt;p&gt;Elliptic curves, being curves, have points. You can define the \(+\) operation on points, such that given points \(P\) and \(Q\) on the curve, you will get a third point \(R\) which is the result of \(P+Q\). To see how to define this visually, you can see it, for example, &lt;a href=&quot;https://www.certicom.com/content/certicom/en/21-elliptic-curve-addition-a-geometric-approach.html&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can also define adding a point \(G\) to itself \(n\) times (\(G+...+G\) with \(n-1\) additions). Call this operation \(n \cdot G\).&lt;/p&gt;

&lt;p&gt;You can ask, given points \(G\) and \(Y\), ‚Äúhow many times would I have to add \(G\) to itself in order to get \(H\)?‚Äù That is, what is the \(n\) such that \(n \cdot G = H\)? This is a hard problem in elliptic-curve cryptography, called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot; target=&quot;_blank&quot;&gt;Discrete Logarithm Problem&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;blind-signatures&quot;&gt;Blind signatures&lt;/h3&gt;

&lt;p&gt;Now we begin solving the problem of tracking. First, let‚Äôs expand our protocol and describe it in more detail.&lt;/p&gt;

&lt;p&gt;Let‚Äôs say the secret key of the Privacy Pass server is the number \(x\) and there‚Äôs a publicly known point on the curve called \(G\) and execute the protocol as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, requesting passes, will create a random token \(t\) and send the server the point \(t \cdot G\), denoting it \(T\). The server will not be able to know \(t\) because of the Discrete Logarithm Problem.&lt;/li&gt;
  &lt;li&gt;The server will create the point \(x \cdot T\). Let‚Äôs call it a &lt;em&gt;signature&lt;/em&gt; and denote it \(Z\). The user will not be able to uncover \(x\) because of DLP.&lt;/li&gt;
  &lt;li&gt;The server will send the signature to the user, which later on will be able to use this signature to prove they received it from the server. Since only the server knows \(x\), only the server could create \(Z = x \cdot T\), and so the server will know they have created these signatures.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This has the problem of tracking, since the server will be able to store all this data and correlate it to the user when the \(Z\)s is used by the user.&lt;/p&gt;

&lt;p&gt;The user, instead of sending \(T\) directly can use a &lt;em&gt;blinding factor&lt;/em&gt; \(r\) to create \(M = r \cdot T = r \cdot t \cdot G\). We call this a &lt;em&gt;blinded token&lt;/em&gt;. Now, when receiving the signature \(Z\) over each \(M\), the user will &lt;em&gt;unblind&lt;/em&gt; the signature by multiplying by the inverse of \(r\): \(r^{-1} \cdot Z = r^{-1} \cdot x \cdot M = r^{-1} \cdot x \cdot r \cdot T = r^{-1} \cdot r \cdot x \cdot T = x \cdot T\). Let‚Äôs denote this result \(N\).&lt;/p&gt;

&lt;p&gt;Although the user could cacluate \(N\), they could never generate it by themselves - since they don‚Äôt know \(x\). Presenting the server \(t\) and \(N\) allows the server to verify they indeed the ones who generated this signature, and the server will not know which &lt;em&gt;blinded token&lt;/em&gt; this signature relates to since they never knew the &lt;em&gt;blinding factor&lt;/em&gt; \(r\).&lt;/p&gt;

&lt;p&gt;The protocol now looks like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The user, requesting passes, will create a random token \(t\) and a blinding factor \(r\) and send the server the point \(r \cdot t\cdot G\), denoting it \(M\).&lt;/li&gt;
  &lt;li&gt;The server will create the point \(x \cdot M\). The server generates a signature \(Z\).&lt;/li&gt;
  &lt;li&gt;The server will send the signature to the user, and the user unblinds the signature, calculating and storing \(N=r^{-1} \cdot M\).&lt;/li&gt;
  &lt;li&gt;The user later on presents \(t\) and \(N\) to the server when they would like to prove their humanity.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It sounds very good! Unfortunately, this doesn‚Äôt solve the problem of tracking, which might not be immediately obvious.&lt;/p&gt;

&lt;p&gt;Assuming the server uses the same secret key \(x\) for all the users requesting passes, this works well. What if the server uses a different \(x\) for every user? We‚Äôre right back to square one - the server, when verifying the signature, will be able to iterate over all the different \(x\)s they generated and thus identify the user.&lt;/p&gt;

&lt;p&gt;This is why it‚Äôs important for the server to show it indeed uses the same secret key \(x\) for all the users. This is done by using a &lt;em&gt;Discrete Logarithm Equality Proof&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;discrete-logarithm-equality-proof&quot;&gt;Discrete Logarithm Equality Proof&lt;/h3&gt;

&lt;p&gt;The server already publishes one point publicly - \(G\). The server could publish publicly an additional point \(Y=x \cdot G\). This is essentially a &lt;em&gt;commitment&lt;/em&gt; to the secret key \(x\).&lt;/p&gt;

&lt;p&gt;The construction of how &lt;em&gt;DLEQ&lt;/em&gt; works requires a bit more math, and I prefer not getting into it in this post. That said, I would like to give a few points to those interested:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;It is similar to the Schnorr identification scheme, proving that the server knows the secret key \(x\) - essentially proving knowledge of ‚Äú\(Y/G\)‚Äù.&lt;/li&gt;
  &lt;li&gt;It uses the non-interactive variant of the scheme using the Fiat-Shamir heuristic, which also has an &lt;a href=&quot;https://tools.ietf.org/html/rfc8235&quot; target=&quot;_blank&quot;&gt;IETF RFC&lt;/a&gt;, converting it from an &lt;em&gt;honest-verifier zero-knowledge&lt;/em&gt; scheme to a &lt;em&gt;non-interactive zero knowledge argument&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;Instead of only proving knowledge of \(Y/G\), it also shows that the &lt;em&gt;same&lt;/em&gt; proof applies to \(Z/M\). This means that the publicly committed secret key, as shown in \(Y\), is the &lt;em&gt;same&lt;/em&gt; one used to create \(Z\) for \(M\), proving that the server used the same secret key to generate the signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A nice description of &lt;em&gt;DLEQ&lt;/em&gt; and some of these details are described in &lt;a href=&quot;https://blog.cryptographyengineering.com/2017/01/21/zero-knowledge-proofs-an-illustrated-primer-part-2/&quot; target=&quot;_blank&quot;&gt;this post by Matthew Green&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you would like more details on the math inolved, feel free to &lt;a href=&quot;https://kobi.one/contact.html&quot; target=&quot;_blank&quot;&gt;reach out&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;finalizing-the-protocol&quot;&gt;Finalizing the protocol&lt;/h3&gt;

&lt;p&gt;By requiring &lt;em&gt;DLEQ&lt;/em&gt;, the server now can‚Äôt cheat and use different secret keys to track users. To make this protocol usable in practice, some other aspects should be considered:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Instead of sending a single token, the user could send multiple tokens to be signed at once.&lt;/li&gt;
  &lt;li&gt;The server should limit the amount of tokens the user can request for each CAPTCHA solution, to prevent abuse by a user dispensing these tokens to other users, essentially making the protection useless.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;The original open-source implementation of Privacy Pass by Cloudflare and the researchers is &lt;a href=&quot;https://github.com/privacypass&quot; target=&quot;_blank&quot;&gt;available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kobigurk/privacypass-rs&quot; target=&quot;_blank&quot;&gt;My implementation of Privacy Pass in Rust is available here&lt;/a&gt;. Some details about it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is fully-compatible with the &lt;a href=&quot;https://github.com/privacypass&quot; target=&quot;_blank&quot;&gt;reference implementation&lt;/a&gt;, both as a server and as a client.&lt;/li&gt;
  &lt;li&gt;It uses &lt;a href=&quot;https://github.com/milagro-crypto/amcl&quot; target=&quot;_blank&quot;&gt;amcl&lt;/a&gt; for elliptic-curve cryptography.&lt;/li&gt;
  &lt;li&gt;It uses &lt;a href=&quot;https://github.com/rust-rocksdb/rust-rocksdb&quot; target=&quot;_blank&quot;&gt;RocksDB&lt;/a&gt; for storage.&lt;/li&gt;
  &lt;li&gt;It is probably compilable to WebAssembly or other architectures with minor modifications.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, it is easy to modify it to support any kind of challenge-solution use-case: login to systems, voting and many more.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Privacy Pass allows adding privacy to a system where initially it seems impossible, by the use of cryptography. It‚Äôs awesome to see that some companies, which have all the means to disregard privacy at the cost of convenience, still go through the R&amp;amp;D and risk required to re-introduce privacy to their systems.&lt;/p&gt;

&lt;p&gt;If you found this interesting and have more questions or suggestions, feel free to &lt;a href=&quot;https://kobi.one/contact.html&quot; target=&quot;_blank&quot;&gt;reach out&lt;/a&gt;, I‚Äôd love to hear from you!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">This post explores Privacy Pass, a protocol which ‚Äúlets users prove their identity across multiple sites anonymously without enabling tracking‚Äù. We will go through the protocol components and eventually see a fully-compatible implementation of Privacy Pass in Rust.</summary></entry><entry><title type="html">Creating fake zkSNARK proofs</title><link href="/2018/07/16/creating-fake-zksnarks-proofs.html" rel="alternate" type="text/html" title="Creating fake zkSNARK proofs" /><published>2018-07-16T00:00:00+03:00</published><updated>2018-07-16T00:00:00+03:00</updated><id>/2018/07/16/creating-fake-zksnarks-proofs</id><content type="html" xml:base="/2018/07/16/creating-fake-zksnarks-proofs.html">&lt;h1 id=&quot;creating-fake-zksnark-proofs&quot;&gt;Creating fake zkSNARK proofs&lt;/h1&gt;

&lt;p&gt;As you may know, zkSNARKs are a way to create Zero-Knowledge Proofs.
Specifically, succinct and non-interactive ones.&lt;/p&gt;

&lt;p&gt;Explaining what they are exactly is a bit too much for this post, so I refer you
to the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://z.cash/technology/zksnarks.html&quot; target=&quot;_blank&quot;&gt;How zkSNARKs are constructed in &lt;/a&gt;
‚Äî by the Zcash team.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/06/08/trustless-computing/&quot; target=&quot;_blank&quot;&gt;Trustless Computing on Private
Data&lt;/a&gt; ‚Äî blog post by
QED‚Äêit‚Äôs lead cryptographer Daniel Benarroch and Prof. Aviv Zohar.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/04/zkp-in-action/&quot; target=&quot;_blank&quot;&gt;Prove-it, Blockchain-it: ZKP in
Action&lt;/a&gt; ‚Äî a video of a meetup
explaining ZKPs and how to create one for Sudoku.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/12/20/the-incredible-machine/&quot; target=&quot;_blank&quot;&gt;The Incredible Machine&lt;/a&gt;
‚Äî blog post by QED‚Äêit‚Äôs Chief Scientist Prof. Aviv Zohar, explaining trusted
setup.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/11/the-hunting-of-the-snark/&quot; target=&quot;_blank&quot;&gt;The Hunting of the
SNARK&lt;/a&gt; ‚Äî a series of
riddles to experiment with ZKPs.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In QED-it we use zkSNARKs, among other tools, to create Zero-Knowledge
Blockchains for the enterprise.&lt;/p&gt;

&lt;p&gt;The production deployment of zkSNARKs that is most known is probably
&lt;a href=&quot;http://z.cash/&quot; target=&quot;_blank&quot;&gt;Zcash&lt;/a&gt; ‚Äî a cryptocurrency with unlinkable transactions and
hidden amounts. Zcash, and some others utilizing zkSNARKs, are based on a
construction called &lt;a href=&quot;https://eprint.iacr.org/2013/279&quot; target=&quot;_blank&quot;&gt;Pinnochio&lt;/a&gt;, although more
specifically &lt;a href=&quot;http://eprint.iacr.org/2013/879&quot; target=&quot;_blank&quot;&gt;BCTV14a&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This is a marvelous technology, and as you might suspect, nothing is for free!
There‚Äôs a notable downside to this construction ‚Äî the ‚Äútrusted setup‚Äù.&lt;/p&gt;

&lt;h3 id=&quot;trusted-setup&quot;&gt;Trusted Setup&lt;/h3&gt;

&lt;p&gt;The setup is a process where the CRS (Common Reference String) is generated, or
more publicly known as the pair of proving and verification keys. These ‚Äúkeys‚Äù
are used by the prover and verifer to generate and verify proofs for a specific
problem (or constraint system), respectively.&lt;/p&gt;

&lt;p&gt;In this process, there are random elements which are sampled and must be kept
secret ‚Äî if the prover knows them, they will be able to create proofs which are
verified successfully, without using an actual solution to the problem during
the proving process. In other words, to forge proofs and break soundness. This
randomness is also known as ‚Äútoxic waste‚Äù.&lt;/p&gt;

&lt;p&gt;There are ways to avoid this worry and not put trust in a single entity. For
public circuits, these usually involve a Multi-Party Computation ‚Äî a process in
which multiple players donate their own randomness, which they destroy
afterwards. The interesting fact is that it‚Äôs enough that one player is honest
and destroys their randomness for the whole process to be secure.&lt;/p&gt;

&lt;p&gt;Some notable examples of using MPCs to do trusted setup are again, by Zcash:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.wnycstudios.org/story/ceremony/&quot; target=&quot;_blank&quot;&gt;‚ÄúThe Ceremony‚Äù podcast&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://z.cash.foundation/blog/powers-of-tau/&quot; target=&quot;_blank&quot;&gt;Powers of Tau&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You might notice this ‚ÄúTau‚Äù that popped up there‚Ä¶&lt;/p&gt;

&lt;p&gt;Not to insult any random element ‚Äî Tau is very important to be kept secret. With
Tau known to the prover ‚Äî it‚Äôs very easy to forge a proof!&lt;/p&gt;

&lt;h3 id=&quot;creating-a-proof&quot;&gt;Creating a proof&lt;/h3&gt;

&lt;p&gt;Let‚Äôs take a quick look at the construction presented in
&lt;a href=&quot;http://eprint.iacr.org/2013/879&quot; target=&quot;_blank&quot;&gt;BCTV14a&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fake1.png&quot; alt=&quot;&quot; style=&quot;width: 100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It‚Äôs math-heavy, so let‚Äôs cherry-pick bits of details relevant to this post:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Tau is a point in a finite field sampled at random, part of the ‚Äútoxic waste‚Äù,
during the setup process.&lt;/li&gt;
  &lt;li&gt;The prover, during the proving process, calculates some polynomials ‚Äî A(z),B(z)
and C(z), which are derived from the constraint system and the public and
private inputs to the solution. Essentially, these polynomials represent
constraints of the form ‚Äúa&lt;em&gt;b=c‚Äù, or equivalently ‚Äúa&lt;/em&gt;b-c=0‚Äù.&lt;/li&gt;
  &lt;li&gt;The prover also calculates H(z) = (A(z)B(z)-C(z))/Z(z), where Z(z) is a publicly
known polynomial which zeros at the points representing the constraint system.
Take note that since A,B and C take the inputs of the prover into account, H can
only be calculated when the numerator also zeros at the same points ‚Äî attesting
to the fact the prover actually knows a solution to the problem, that which
yields A*B-C = 0.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The important part happens now ‚Äî the prover, while not knowing Tau, can
calculate ‚Äúin-the-exponent‚Äù H(z) evaluated at Tau ‚Äî \(H(\tau)\)!&lt;/p&gt;

&lt;p&gt;Why do we do that? Since by evaluating at the random point Tau, the prover shows
with high probability that the equation H=(A*B-C)/Z holds for all z. From a
different perspective on the same matter, without knowing Tau, the prover, with
high probability, will not be able to produce a polynomial which receives the
exact same value at that point.&lt;/p&gt;

&lt;p&gt;How can we technically do that? By the fact that part of the setup process
generated elements containing all the relevant powers of Tau, hidden in the
exponent, given as \(pk_{H_i}\). If we have the coefficients of H, we can combine these
and create \(H(\tau)\).&lt;/p&gt;

&lt;p&gt;More specifically:&lt;/p&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(H(z) = \sum{h_i \cdot z^i }\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Calculated H(z) by the prover&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\({pk}_{H_i} = \tau^i \cdot G_i\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Taken from the proving key, calculated in the setup process&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table class=&quot;centeredimg&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;\(\sum{h_i \cdot {pk}_{H_i} } = \sum{h_i \cdot \tau^i \cdot G_1} = H(\tau) \cdot G_1\)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Evaluating \(H(\tau)\) ‚Äúin-the-exponent‚Äù&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The verifier, upon receiving the proof, can check, again in-the-exponent, that
the prover indeed provided coefficients for H which satisfy the relation
H=(A*B-C)/Z, which can only be done if the prover actually knew a solution.&lt;/p&gt;

&lt;h3 id=&quot;forging-a-proof&quot;&gt;Forging a proof&lt;/h3&gt;

&lt;p&gt;Now let‚Äôs have some fun‚Ä¶ What happens if Tau is known? If, by some reason, it
was exposed during the setup process and is known to a malicious prover?&lt;/p&gt;

&lt;p&gt;Apparently, it‚Äôs very easy to forge a proof ‚Äî since the equality check for
H=(A*B-C)/Z is done is at the specific point Tau, we can use our knowledge of
Tau to create a polynomial which satisfies exactly that! That is, create a
constant polynomial H(z), which just returns \((A(\tau) \cdot B(\tau)-C(\tau))/Z(\tau)\) all
the time.&lt;/p&gt;

&lt;p&gt;The verifier‚Äôs check will pass, and none‚Äôs the wiser!&lt;/p&gt;

&lt;h3 id=&quot;sounds-hard&quot;&gt;Sounds hard‚Ä¶&lt;/h3&gt;

&lt;p&gt;Not at all ‚Äî you‚Äôre more than welcome to check &lt;a href=&quot;https://github.com/QED-it/libsnark-tutorial_forge_proof&quot; target=&quot;_blank&quot;&gt;this proof-of-concept
code&lt;/a&gt;, based on Howard
Wu‚Äôs &lt;a href=&quot;https://github.com/howardwu/libsnark-tutorial&quot; target=&quot;_blank&quot;&gt;libsnark-tutorial&lt;/a&gt;, and see
for yourself the changes made to the code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The program sets up a circuit for bit-decomposition ‚Äî this is an example, and it could have been any circuit.&lt;/li&gt;
  &lt;li&gt;The setup process maliciously saves Tau to disk.&lt;/li&gt;
  &lt;li&gt;The prover loads Tau from disk, and uses wrong inputs to the proof. The prover,
knowing Tau, generates the constant polynomial, disregarding the inputs.&lt;/li&gt;
  &lt;li&gt;The verifier then verifies the proof successfully ‚Äî bamboozled!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h3&gt;

&lt;p&gt;I hope this post provided some insight into what is this ‚Äútoxic waste‚Äù that
everyone has been talking about regarding zkSNARKs, and why having it exposed
leads to an easily executable attack.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">As you may know, zkSNARKs are a way to create Zero-Knowledge Proofs. They do require a trusted setup. What happens when the setup is compromised?</summary></entry><entry><title type="html">Zero-Knowledge taxation on Ethereum</title><link href="/2018/06/24/zkp-qed-ethereum.html" rel="alternate" type="text/html" title="Zero-Knowledge taxation on Ethereum" /><published>2018-06-24T00:00:00+03:00</published><updated>2018-06-24T00:00:00+03:00</updated><id>/2018/06/24/zkp-qed-ethereum</id><content type="html" xml:base="/2018/06/24/zkp-qed-ethereum.html">&lt;p&gt;At QED‚Äêit, we have a mission to provide privacy preserving systems for the enterprise. For the last two years, we‚Äôve worked on many projects, developing complex SNARK circuits and higher level protocols to tackle different use-cases - asset management, supply chain, real-time risk assessment, predictive maintenance, credit scoring and more.&lt;/p&gt;

&lt;p&gt;We are happy to present one such project that has been done in collaboration with Deloitte. The project has been in the works for the last few months, in which the team in Deloitte utilized the QED‚Äêit SDK to deploy a Zero-Knowledge Blockchain for their chosen use-case ‚Äî new french tax rules presented in 2018.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Watch the talk by Jonathan Rouach, our CEO, at ZCon0:&lt;/p&gt;
&lt;style&gt;.embed-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; } .embed-container iframe, .embed-container object, .embed-container embed { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }&lt;/style&gt;
&lt;div class=&quot;embed-container&quot;&gt;    &lt;iframe title=&quot;YouTube video player&quot; width=&quot;640&quot; height=&quot;390&quot; src=&quot;//www.youtube.com/embed/OTO4JCJZD2o&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;h1 id=&quot;use-case&quot;&gt;Use-case&lt;/h1&gt;

&lt;p&gt;It is common for a person to purchase a life insurance contract from an insurer. The person then performs deposits to this contract. In ‚Äúinvestment-type‚Äù contracts, these deposits are invested by the insurer in different investment vehicles, possibly earning gains.&lt;/p&gt;

&lt;p&gt;At some point, the person would like to withdraw their money from the insurer. The question arises - how should these gains be taxed, before paying to the person?&lt;/p&gt;

&lt;p&gt;This is where a friction point arises - the new 2018 french tax law binds the calculation of the tax to the &lt;em&gt;accumulated value&lt;/em&gt; of all life insurance contracts held by the beneficiary.&lt;/p&gt;

&lt;p&gt;When the person has contracts with a single insurer, then, naturally, all the data relevant for calculating the tax is held by this insurer. Since it is also possible for a person to purchase life insurance contracts from multiple insurers, a person might not want to expose this highly personal data to the insurer the person is withdrawing from.&lt;/p&gt;

&lt;p&gt;What if we had a system, allowing a person to use all of the life insurance contracts from their insurers, and calculate the tax the insurer should pay, without leaking information about other contracts at other insurers?&lt;/p&gt;

&lt;h1 id=&quot;zero-knowledge-proofs&quot;&gt;Zero-knowledge proofs&lt;/h1&gt;

&lt;p&gt;Zero-knowledge proofs (ZKPs) allow a verifier to pose a question to a prover, and the prover answers this question, using whatever private data needed to answer it, revealing nothing more than the answer to the question itself.&lt;/p&gt;

&lt;p&gt;An example of a question a verifier could pose is ‚Äúdo you know the solution to the following Sudoku puzzle?‚Äù. Obviously, the prover who knows the solution can show the solution itself. This prover, though, would like to keep the solution secret for now, but convince the verifier that they do know the solution. The prover can use a zero-knowledge proof to just answer ‚Äúyes‚Äù! The cryptographic proof also serves for convincing the verifier that the right question was used on the right data and no one altered the result.&lt;/p&gt;

&lt;p&gt;zkSNARKs are, amongst other properties, a way to do this process:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Non-interactively&lt;/em&gt; - without a direct interaction between the prover and the verifier.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Succinctly&lt;/em&gt; - the proofs are very small.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Explaining zero-knowledge proofs in depth is beyond the scope of this post, and if you wish to know more, I invite you to check out the following resources:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/06/08/trustless-computing/&quot;&gt;Trustless Computing on Private Data&lt;/a&gt; - blog post by QED‚Äêit‚Äôs lead cryptographer Daniel Benarroch and Prof. Aviv Zohar.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/04/zkp-in-action/&quot;&gt;Prove-it, Blockchain-it: ZKP in Action&lt;/a&gt; - a video of a meetup explaining ZKPs and how to create one for Sudoku.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/12/20/the-incredible-machine/&quot;&gt;The Incredible Machine&lt;/a&gt; - blog post by QED‚Äêit‚Äôs Chief Scientist Prof. Aviv Zohar, explaining trusted setup.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://qed-it.com/2017/07/11/the-hunting-of-the-snark/&quot;&gt;The Hunting of the SNARK&lt;/a&gt; - a series of riddles to experiment with ZKPs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;the-project&quot;&gt;The project&lt;/h1&gt;

&lt;h2 id=&quot;qed-it-sdk&quot;&gt;QED-it SDK&lt;/h2&gt;
&lt;p&gt;At the heart of the QED‚Äêit SDK is an &lt;em&gt;identity&lt;/em&gt; protocol. This protocol serves as a framework for committing to data by issuers, attesting pieces of data about a user, and allowing an auditor to pose audit questions to this user. The user, in turn, generates a zero-knowledge proof that combines the data inputs and uses a computation on them to answer the audit question.&lt;/p&gt;

&lt;p&gt;The QED‚Äêit SDK provides this protocol adapted to families of use-cases, especially the ones discussed and deemed important in the recent &lt;a href=&quot;https://zkproof.org&quot;&gt;Zero Knowledge Proof Standardization&lt;/a&gt; workshop. The adaptations includes a set of building blocks for each of these families, allowing an auditor to pose increasingly complex audit questions.&lt;/p&gt;

&lt;p&gt;Why is it called an SDK? Well, the SDK allows developers to write ‚Äúhooks‚Äù - their own audit questions using a Domain-Specific Language. The encompassing protocols provide the security guarantees required by most of the use-cases.&lt;/p&gt;

&lt;h2 id=&quot;high-level-design&quot;&gt;High-level design&lt;/h2&gt;

&lt;p&gt;Let‚Äôs start with a diagram describing the system:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/zkpqed1.jpeg&quot; alt=&quot;System diagram&quot; style=&quot;width: 100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;User, Insurer 1 and Insurer 2 are QED‚Äêit nodes. The nodes give the ability to publish commitments about bits of data and generate ZKPs in response to audit questions.&lt;/p&gt;

&lt;p&gt;Step-by-step (using the numbering of the diagram), this is how a possible system communication scenario looks like:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Insurer 1 sends the life insurance contract to the user, attesting to the contract between them.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insurer 1 publishes commitments, in the form of hashes, of the contract. These are small values not exposing any information about the contract itself.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(This covers 3-8). The commitments are propagated throughout the network. Additionally, Insurer 2 does the same publishing steps as Insurer 1.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The user requests to leave Insurer 2. The insurer has to pay the gains to the user, minus the taxes owed for them. In order to know the tax amounts, the insurer poses an audit question to the user - ‚Äúgiven your life insurance contracts at all of your insurers, what is the tax amount that should be paid for the gains for the deposits you made to us?‚Äù&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The user collects all their life insurance contracts, and generates a zero-knowledge proof of the calculated tax amounts.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;After receiving the ZKP, Insurer 2 pays the user, minus the taxes on the gains according to the law, all this without knowing any details about the other life insurance contracts the user holds! (Except, of course, what can be inferred from the audit question itself)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I‚Äôd like to highlight an important fact which may not be obvious - throughout this process, the data, once collected by the user, never left the user‚Äôs node! Still, the user can calculate by themselves the tax rates, with the insurer being certain that the result is correct.&lt;/p&gt;

&lt;p&gt;In a centralized world, in order for the insurers to comply with the law, they must have more information, and so the user usually provides it to them. In the QED-it world, it‚Äôs not like that anymore! The users perform the math on their own machines, and they just need the right infrastructure to support this - users running QED-it nodes to generate ZKPs and insurers committing data and verifying proofs.&lt;/p&gt;

&lt;h2 id=&quot;modularization-and-domain-specific-language-dsl&quot;&gt;Modularization and Domain-Specific Language (DSL)&lt;/h2&gt;

&lt;p&gt;QED‚Äêit‚Äôs SDK allows users to write their ‚Äúbusiness-logic‚Äù proofs both in our embedded DSL and and other external DSLs - languages for the domain of Zero-Knowledge Proofs.&lt;/p&gt;

&lt;p&gt;The main requirement for this integration is that the proofs conform to the &lt;em&gt;proof-chaining&lt;/em&gt; specification. Proof-chaining is a technique we‚Äôve implemented that allows a prover to connect different proofs parts, even between different proof systems. This allows the DSL proofs to be connected  with the other parts of the QED‚Äêit‚Äôs proofs and protocol.&lt;/p&gt;

&lt;p&gt;A bit more in-depth, the proof in this use-case is modularized to multiple proofs, ‚Äúglued‚Äù together:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Data validity proofs.&lt;/em&gt; These promise:
    &lt;ol&gt;
      &lt;li&gt;The data has been published before by one of the approved parties, and existed by block X, referenced by a ‚Äúmerkle root‚Äù of the merkle tree generated by all the published commitments.&lt;/li&gt;
      &lt;li&gt;The data has not been revoked by block Y.&lt;/li&gt;
      &lt;li&gt;The subset of the data that will be chained to the next proof has been generated correctly, referenced by a hiding commitment to it.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;As you may notice, we‚Äôve introduced a new concept here, a Merkle tree. Specifically, the commitments in the system are collected in an append-only Merkle tree - a data structure that has efficient proofs for ‚Äúset membership‚Äù -given a set S and an element x, you can efficiently show x is an element in the set S.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Tax proof.&lt;/em&gt; This is the proof containing the specific business logic of the proof, which in this case means the calculation of the tax amounts. This proof assumes the data inputs have been validated by other proofs. This assumption causes this proof to be very small and efficient!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The different proof components are connected by what we call a glue.&lt;/p&gt;

&lt;p&gt;The verification protocol then, in addition to verifying that the merkle roots existed in the past, includes verification of the ‚Äúglue‚Äù components between the different proofs.&lt;/p&gt;

&lt;p&gt;The calculation of tax amounts in the &lt;em&gt;Tax Proof&lt;/em&gt; has been written by Aliz√©e Faytre, who has been the developer in Deloitte working on the project under the supervision of Ossama Benbouidda and Julien Maldonato, using &lt;a href=&quot;https://github.com/JacobEberhardt/ZoKrates&quot;&gt;ZoKrates&lt;/a&gt; ‚Äî a Python-like high level language that compiles into zkSNARKs.&lt;/p&gt;

&lt;h2 id=&quot;external-verifiers&quot;&gt;External verifiers&lt;/h2&gt;

&lt;p&gt;An important part of this project was allowing an external party who is not running a QED‚Äêit node to enjoy the results of the zero-knowledge proof generated by the user‚Äôs QED‚Äêit node.&lt;/p&gt;

&lt;p&gt;To do that, we chose to deeply integrate with an Ethereum network, which, since the &lt;a href=&quot;https://blog.ethereum.org/2017/10/12/byzantium-hf-announcement/&quot;&gt;Byzantium hard-fork&lt;/a&gt;, allowing zkSNARKs proofs verification by providing precompiles for efficient evaluation of elliptic curve operations on the BN128 curve. In short, this means that we can generate proofs using a QED-it node and verify them in a decentralized manner on the Ethereum blockchain.&lt;/p&gt;

&lt;p&gt;We implemented a smart contract that essentially acts as an autonomous verifier. This smart contract allows the different parties to publish commitments that will be collected in an incremental merkle tree, and run the verification protocol on the bundle of proofs generated by the user.&lt;/p&gt;

&lt;p&gt;This allows, for example, for a smart contract managing the wallet of the insurer, to consume the tax proofs, pay the taxes to the government and pay the user minus the tax. This coincides with our vision of real-time regulation compliance.&lt;/p&gt;

&lt;h2 id=&quot;the-system-in-action&quot;&gt;The system in action&lt;/h2&gt;

&lt;p&gt;We deployed the system comprising a set of 6 nodes - 5 insurers and 1 user, running a Proof-of-Authority Ethereum network. These parties run QED‚Äêit nodes and have the ability to generate these proofs, using our own efficient data validity proofs and to generate the tax proof using ZoKrates.&lt;/p&gt;

&lt;p&gt;The nodes are easily deployable using Docker and are exposing an HTTP API to be easily integrated with.&lt;/p&gt;

&lt;p&gt;Along with its node, comes QED-it‚Äôs explorer tool, that realizes our vision of a ZKP monitoring system and allows operators of nodes to monitor the activity of their nodes, just like a block explorer allows one to monitor a blockchain. This is how the process looks like there:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data report by an insurer:
&lt;img src=&quot;/assets/images/zkpqed2.png&quot; alt=&quot;Data report&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Commitment publish by an insurer:
&lt;img src=&quot;/assets/images/zkpqed3.png&quot; alt=&quot;Commitment publish&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Tax calculation result:
&lt;img src=&quot;/assets/images/zkpqed4.png&quot; alt=&quot;Audit&quot; style=&quot;width: 100%&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;challenges&quot;&gt;Challenges&lt;/h2&gt;

&lt;p&gt;This project uses bleeding-edge technology, and as you can imagine, it posed a few challenges:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The smart contract implementing the autonomic verifier has to maintain a history of ‚Äúknown merkle roots‚Äù - each time a commitment is published to the contract, the new root should be calculated and kept.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Doing this naively is an issue - as this is an incremental tree, commitments are never deleted, so it‚Äôs best to use as large as possible tree. We chose a tree of depth 30, supporting about a billion of commitments. Managing this large a tree directly in a smart contract is not practical.&lt;/p&gt;

&lt;p&gt;To cope with that, we implemented an efficient incremental merkle tree in Solidity.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The gas requirements for the pairing operations needed to verify proofs are pretty high - verifying a single proof consumes about 2 million gas.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is where the different trade-offs between the systems come into friction - on the one hand, modularization of proofs allows for more versatile, practical and secure proofs, and on the other hand, we would like to minimize the amount of gas used in the contract.&lt;/p&gt;

&lt;p&gt;There are possibilities to make good trade-offs - using different modularization techniques, combining proofs using &lt;a href=&quot;http://eprint.iacr.org/2012/095&quot;&gt;Proof-Carrying Data&lt;/a&gt; and many more. In a private Ethereum network, it even becomes a non-issue, with the ability to introduce new precompiles.&lt;/p&gt;

&lt;p&gt;Also, there are proposals to decrease the amount of gas, which will improve this situation.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The glue component in the tax proof requires the use of hashes in ZoKrates. We have made efforts to integrate efficient external circuits and are hoping to collaborate with the ZoKrates team to make more integration possibilities a reality.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;

&lt;p&gt;In this post, we‚Äôve seen an end-to-end zero-knowledge system to allow real-time taxation with exposing the user‚Äôs private data. This is just scratching the surface of the possibilities of practically using zero-knowledge proofs and other privacy preserving tools, in which we specialize in QED‚Äêit.&lt;/p&gt;

&lt;p&gt;Of course, many technical details have been omitted for brevity, and there‚Äôs much more to the story. I invite you to write to us at &lt;a href=&quot;mailto:info@qed-it.com&quot;&gt;info@qed-it.com&lt;/a&gt; to learn more about the SDK.&lt;/p&gt;

&lt;p&gt;If you‚Äôre attending &lt;a href=&quot;https://z.cash.foundation/zcon/&quot;&gt;ZCon0&lt;/a&gt;, you‚Äôre welcome to meet some of our team and attend our CEO‚Äôs talk about ‚ÄúZero Knowledge In The Enterprise‚Äù on day 2 at 9:10AM and the ZKProof workshop on the same day at 1PM, lead by our Daniel Benarroch and Eran Tromer.&lt;/p&gt;

&lt;p&gt;We are also &lt;a href=&quot;https://qed-it.com/jobs/&quot;&gt;hiring&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;I hope this has been enjoyable, and that it ignites the imagination as to what is now possible in a privacy preserving world!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">At QED‚Äêit, we have a mission to provide privacy preserving systems for the enterprise. For the last two years, we‚Äôve worked on many projects, developing complex SNARK circuits and higher level protocols to tackle different use-cases - asset management, supply chain, real-time risk assessment, predictive maintenance, credit scoring and more. We are happy to present one such project that has been done in collaboration with Deloitte. The project has been in the works for the last few months, in which the team in Deloitte utilized the QED‚Äêit SDK to deploy a Zero-Knowledge Blockchain for their chosen use-case ‚Äî new french tax rules presented in 2018.</summary></entry><entry><title type="html">Cryptocurrency recovery (or ‚ÄúWhat the BIP is all of this?‚Äù)</title><link href="/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this.html" rel="alternate" type="text/html" title="Cryptocurrency recovery (or ‚ÄúWhat the BIP is all of this?‚Äù)" /><published>2017-12-10T00:00:00+02:00</published><updated>2017-12-10T00:00:00+02:00</updated><id>/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this</id><content type="html" xml:base="/2017/12/10/cryptocurrency-recovery-or-what-the-bip-is-all-of-this.html">&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;TL; DR&lt;/h2&gt;
&lt;h3 id=&quot;what-i-can-help-with&quot;&gt;What I can help with&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Got any type of coin stuck for which you saved some backup and want to consult whether they can be rescued? Contact me - &lt;a href=&quot;mailto:kobigurk@gmail.com&quot;&gt;kobigurk@gmail.com&lt;/a&gt;!&lt;/li&gt;
  &lt;li&gt;Want me to walk you through the recovery process? Gladly!&lt;/li&gt;
  &lt;li&gt;Want to consult how to properly backup your private keys in order to be able to recover your coins in the future? Contact me :-)
    &lt;h3 id=&quot;how-to-recover-by-yourself&quot;&gt;How to recover by yourself&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in an address whose private key you have? Use &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in an Electrum wallet whose 24 words seed you saved? Use the &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;BIP39 tool&lt;/a&gt; to derive the private keys and then use &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Got Bitcoins stuck in a Ledger Nano S who was destroyed but you have the 24 words saved? Import them into Electrum&lt;/li&gt;
  &lt;li&gt;Got any type of coin stuck in a Ledger Nano S who was destroyed but you have the 24 words saved? Use the &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;BIP39 tool&lt;/a&gt; to get your private keys and use their respective wallets to import them&lt;/li&gt;
  &lt;li&gt;Got Bitcoin Cash or Bitcoin Gold stuck in a multi-sig address in Electrum/Copay/anything, but have access to your Bitcoins? It‚Äôs a bit more complex, but possible - read through the deep dive or contact me - I can help!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Want to know more about the technical details? Keep reading.&lt;/p&gt;

&lt;h1 id=&quot;deep-dive&quot;&gt;Deep dive&lt;/h1&gt;
&lt;p&gt;Having Bitcoins is nice and having them being stored securely is even nicer. Though, as often is the case, the additional security often invites complexity to frequent use of your money. There are great software and hardware solutions that make your money safer than ever.&lt;/p&gt;

&lt;p&gt;What‚Äôs nice about these solutions is that they hide the complexity of securing your money and give you the best-practice approach to do it. The problem is that they deal with the specific use-case they had in mind and are less flexible when you‚Äôd like to deviate a bit from the usual path.&lt;/p&gt;

&lt;p&gt;For example, let‚Äôs say you use &lt;a href=&quot;http://docs.electrum.org/en/latest/2fa.html&quot;&gt;Electrum 2FA (Two-Factor Authentication)&lt;/a&gt;. It‚Äôs a great solution that uses &lt;a href=&quot;https://api.trustedcoin.com&quot;&gt;TrustedCoin&lt;/a&gt; as a co-signer to each of your transactions. Quoting from them,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;With a two-factor setup, your computer cannot spend your bitcoins without your entering a code from your cell phone. You will have significantly increased security.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That‚Äôs great! And there‚Äôs also a backup key that allows you to recover your Bitcoins in case TrustedCoin ever goes offline, so you‚Äôre safe. But‚Ä¶&lt;/p&gt;

&lt;p&gt;Recently some forks in Bitcoin happened. There‚Äôs Bitcoin Cash, Bitcoin Gold and maybe some more precious metal variants in the near-future. Those variants operate on a different chain than the usual Bitcoin, and that means that Electrum and TrustedCoin do not support it.&lt;/p&gt;

&lt;p&gt;Damn.&lt;/p&gt;

&lt;p&gt;If both my wallet and the co-signing service do not support Bitcoin Gold‚Ä¶ I‚Äôm stuck! They hid all the complexity of how they secured me and now I don‚Äôt know how to recover.&lt;/p&gt;

&lt;p&gt;That was just an example of a situation that can happen in many other use-cases - hardware wallets (such as &lt;a href=&quot;https://www.ledgerwallet.com/r/6a0a?path=/products/ledger-nano-s&quot;&gt;Ledger Nano S&lt;/a&gt; which I absolutely recommend), multi-sig wallets such as &lt;a href=&quot;https://copay.io/&quot;&gt;Copay&lt;/a&gt; and others.&lt;/p&gt;

&lt;p&gt;It‚Äôs important to stress that usually the developers of the different platforms are doing an awesome job - they give you all the necessary bits of data that enable recovery. What they don‚Äôt do, understandably, is supporting every different recovery method that a user would like to have.&lt;/p&gt;

&lt;p&gt;For example, if your Ledger Nano S hardware wallet is destroyed because you were trading while taking a bath, the main recommendation is to buy a new one and use the ‚Äúseed words‚Äù you were given when you created your wallet. That‚Äôs great, but what if Ledger goes bankrupt? I have to rummage through ebay to find rare Ledgers? Meh.&lt;/p&gt;

&lt;p&gt;How to store Bitcoins securely is a different matter I won‚Äôt get into right now, but I want to tell you some &lt;strong&gt;good news&lt;/strong&gt;: most of the wallets I mentioned here and many others use similar methods to store your coins, and that means that most of the steps of recovery are the same.&lt;/p&gt;

&lt;p&gt;In this post I will survey the preliminaries to understand how wallets store your Bitcoins (and other coins) using a single seed, how you would recover your Bitcoins in case you decide (or can) not to use a specific service anymore and what is the backup data you should keep in order to facilitate that.&lt;/p&gt;

&lt;h1 id=&quot;preliminaries&quot;&gt;Preliminaries&lt;/h1&gt;
&lt;p&gt;Bitcoin development happens through BIPs. These are Bitcoin Improvement Proposals. They are announced on the mailing list and assigned a number. Roughly, if there‚Äôs strong support behind it, it‚Äôs implemented in Bitcoin clients.&lt;/p&gt;

&lt;p&gt;Following is a high-level description of some of the BIPs that support the mechanism with which different wallets manage private keys.&lt;/p&gt;

&lt;h2 id=&quot;bip32&quot;&gt;BIP32&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki&quot;&gt;BIP32&lt;/a&gt; describes a standard way to generate multiple addresses and private keys from a single private key, in a secure way. The exact technical details can be read in the BIP itself, but I‚Äôll highlight the ones I feel important:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A parent (extended) private key can generate many distinct children private keys by an index.&lt;/li&gt;
  &lt;li&gt;The derivation can be done in a ‚Äúnormal‚Äù way or a hardened way, where a significant security difference exists - in the normal way, it‚Äôs possible (with some additional meta-data) to retrieve the parent private key from a child private key, but you gain an interesting feature - given the parent &lt;strong&gt;public&lt;/strong&gt; key, you can view all of its normal children public keys and, for example, monitor their balance.&lt;/li&gt;
  &lt;li&gt;The way you represent this derivation is by a &lt;strong&gt;path&lt;/strong&gt; - something like ‚Äúm/0‚Äô/0‚Äù. This path means - take the (extended) private key, take its hardened child 0 and then from that resulting private key take the normal child 0 - and then you gain a private key you can use.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In drawings it looks like this:
&lt;img src=&quot;/content/images/2017/12/SoWkIImgAStDuSfLqBLJC53dKZ9GLm8pkHnIyrA0CW00.png&quot; alt=&quot;path&quot; /&gt;
translates to
&lt;img src=&quot;/content/images/2017/12/Untitled.png&quot; alt=&quot;path translated&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bip39&quot;&gt;BIP39&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki&quot;&gt;BIP39&lt;/a&gt; describes a standard way to generate a private key from a sequence of human-readable words.&lt;/p&gt;

&lt;p&gt;From the user‚Äôs perspective, she has a Mnemonic Sentence - a sequence of &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md&quot;&gt;words&lt;/a&gt; from which a binary array is derived. The exact number of words is related to the amount of entropy which translates to the level of security. Ledger Nano S, for example, uses a 24 word sequence.&lt;/p&gt;

&lt;p&gt;There‚Äôs an awesome &lt;a href=&quot;https://iancoleman.io/bip39/&quot;&gt;tool&lt;/a&gt; by &lt;a href=&quot;https://github.com/iancoleman&quot;&gt;Ian Coleman&lt;/a&gt; that allows you to generate the master private key given your mnemonic sentence, and following that, the children private keys derived from that. You can even run this tool offline by either compiling it yourself, or saving the html and running it on an offline computer.&lt;/p&gt;

&lt;h2 id=&quot;bip44&quot;&gt;BIP44&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki&quot;&gt;BIP44&lt;/a&gt; uses BIP32 and describes a standard way to generate private keys such that you can use the same master private key for different cryptocurrencies or use-cases without risk.&lt;/p&gt;

&lt;p&gt;That is, it standardizes the path that is used by BIP32:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m / purpose' / coin_type' / account' / change / address_index
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;purpose - constant &lt;strong&gt;44‚Äô&lt;/strong&gt;, to signify that this is a BIP44-compatible derivation.&lt;/li&gt;
  &lt;li&gt;coin_type - different coins have different numeric types. Bitcoin is 0 and there seems to be consensus that Ethereum is 60, Litecoin is 2 and many others. Ian Coleman‚Äôs tool has an extensive list of these, but a wallet doesn‚Äôt have to conform to it - the coin type is just a convention.&lt;/li&gt;
  &lt;li&gt;account - maybe you are managing wallets for different users or purposes. This element in the path allows you to distinguish them by assigning different indices to them.&lt;/li&gt;
  &lt;li&gt;change - is this an address that receive money, or a change addresses that just received change resulting from money I sent to someone? Can be 0 or 1.&lt;/li&gt;
  &lt;li&gt;address_index - the index of the address in this account, because you‚Äôre using a new address in each transaction when possible‚Ä¶ I hope!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The literal meaning is - you take the master private key, you go to the purpose-indexed hardened child, the coin_type-indexed hardened child of it, the account-indexed hardened child of that, the change-indexed normal child of this and finally the address_index-indexed normal child of those.&lt;/p&gt;

&lt;h2 id=&quot;bip16&quot;&gt;BIP16&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki&quot;&gt;BIP16&lt;/a&gt; is a bit more complex to describe in a few words that also convey the motivation, but I‚Äôll try - it describes a general way to encode complex scripts in a way that‚Äôs compatible with single-address schemes and moves the burden of paying the fee for these complex scripts from the sender to the receiver.&lt;/p&gt;

&lt;p&gt;Such a complex script can be M-out-of-N multi-sig - an address from which you can only spend using M signatures out of N parties involved. This mechanism is used, for example, in Electrum 2FA, with a 2-out-of-3 multi-sig.&lt;/p&gt;

&lt;p&gt;Bitcoin‚Äôs scripting language is rich and I gave a talk on how it works and other interesting scripts you can use in the &lt;a href=&quot;https://drive.google.com/open?id=0B-EU9txb0XfwYkE1eFFVLW1tLU0&quot;&gt;BlockchainWTB conference&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;recovery&quot;&gt;Recovery&lt;/h1&gt;
&lt;h2 id=&quot;types-of-addresses&quot;&gt;Types of addresses&lt;/h2&gt;
&lt;p&gt;Now we‚Äôre getting to the juicy stuff! We now know all the ingredients we need to recover from many different situation and I‚Äôm to describe some of these through concrete examples.&lt;/p&gt;

&lt;h3 id=&quot;p2pkh-regular-addresses&quot;&gt;P2PKH (regular addresses)&lt;/h3&gt;
&lt;p&gt;When you use your new Ledger Nano S for the first time, it walks you through a setup process. In this process, you are presented with a mnemonic sentence of 24 words.&lt;/p&gt;

&lt;p&gt;Now you know that these words actually generate a master private key for your Ledger using BIP39.&lt;/p&gt;

&lt;p&gt;When you use your different wallet in the chrome apps that Ledger supplies you with, you are actually using the same master private key but with different coin types, account indices and address indices, as specified in BIP44.&lt;/p&gt;

&lt;p&gt;Even more, the awesome guys at Ledger give you the option to see the exact path to your addresses - just go to your account settings in one of the wallet apps, and you will see a path that looks like a BIP44 path - ‚Äúm/44‚Äô/0‚Äô/0‚Äù.&lt;/p&gt;

&lt;p&gt;So, if you want to recover from situation where Ledger doesn‚Äôt work anymore, you could import it into Electrum, for example.&lt;/p&gt;

&lt;p&gt;Let‚Äôs assume, though, you‚Äôd like to know for 100% you don‚Äôt depend on any single wallet software to exist anymore - you can use the BIP39 tool and see the private keys there and generate transactions using these private keys using any Bitcoin wallet you‚Äôd like. That can be &lt;a href=&quot;https://bitcoin.org/en/download&quot;&gt;Bitcoin Core&lt;/a&gt; or even a Bitcoin library such as &lt;a href=&quot;https://bitcoinjs.org/&quot;&gt;BitcoinJS&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;p2sh-multi-sig&quot;&gt;P2SH (multi-sig)&lt;/h3&gt;
&lt;p&gt;P2SH is BIP16 - roughly, the method to use complex scripts such as multi-sig, as used by Electrum 2FA, Copay and others.&lt;/p&gt;

&lt;p&gt;Recovering from a multi-sig wallet service going offline is a bit more complex, but it‚Äôs still possible.&lt;/p&gt;

&lt;p&gt;Let‚Äôs examine a 2-out-of-3 multi-sig Bitcoin wallet case. In this case, the address is derived from the &lt;strong&gt;3&lt;/strong&gt; &lt;strong&gt;public&lt;/strong&gt; keys of the different participants. Let‚Äôs assume we have these:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A primary key which you own and use in the usual transactions&lt;/li&gt;
  &lt;li&gt;a backup key which you store offline&lt;/li&gt;
  &lt;li&gt;the key of a wallet protection service, such as TrustedCoin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To transact from this address, you‚Äôd have to sign the transaction using &lt;strong&gt;2&lt;/strong&gt; of the &lt;strong&gt;private&lt;/strong&gt; keys. In this case, you‚Äôd usually use your primary one and the wallet protection service would provide the second signature. In case the wallet protection service goes offline, you‚Äôd use your primary and backup key.&lt;/p&gt;

&lt;p&gt;The thing is, that in order to transact from a P2SH address you don‚Äôt need just the 2 private keys, but also a &lt;strong&gt;redeem script&lt;/strong&gt; derived from the 3 public keys. That means, that in order to successfully recover, you also need this redeem script. So make sure you save that as well.&lt;/p&gt;

&lt;h2 id=&quot;ok-fine-how-to-actually-do-it&quot;&gt;OK, fine‚Ä¶ How to actually do it?&lt;/h2&gt;
&lt;p&gt;For normal addresses, an ideal recovery software would roughly do this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use BIP39 with your seed words to recover your master private key&lt;/li&gt;
  &lt;li&gt;Collect the unspent outputs of the address you want to spend from - these are the Bitcoins you‚Äôll send&lt;/li&gt;
  &lt;li&gt;Sign a transaction that sends money from this address to a destination address for your choosing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;An example of such tool that automates a lot of this process in the case of Bitcoin Cash and Bitcoin Gold forks is &lt;a href=&quot;https://github.com/shesek/bcash-instadump&quot;&gt;bcash-instadump&lt;/a&gt; by Nadav Ivgi.&lt;/p&gt;

&lt;p&gt;For P2SH addresses, you‚Äôd have to do the same, but when you sign the transaction, you‚Äôd provide multiple private keys and the redeem script. This redeem script is easily attainable in good wallets such as Electrum. I had such a case and wrote some code that uses exactly this redeem script to extract Bitcoin Gold using BitcoinJS.&lt;/p&gt;

&lt;p&gt;For other types of coins that use this scheme the recovery process is similar in theory, but it usually requires a different set of libraries and wallet software. For instance, in Ethereum, you may use &lt;a href=&quot;myetherwallet.com&quot;&gt;MyEtherWallet&lt;/a&gt; with the derived private keys.&lt;/p&gt;

&lt;p&gt;If you have some stuck Zcash, you may notice that the BIP39 tool misses it. That‚Äôs actually because of a technical limitation in BitcoinJS - Zcash use an address prefix which is 2 bytes, but BitcoinJS only supports a single-byte address prefixes. I have a hacky-fix from it that I use, but it‚Äôs not generic enough to publish.&lt;/p&gt;

&lt;p&gt;For some coins (such as Bitcoin Gold), there are also some wallets that supports the import of single-address private keys, but are not open-source. That doesn‚Äôt immediately mean the wallet developers are malicious, but it bugs me to use something proprietary like this for sensitive matters like money.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I hope this post would encourage people to take advantage of the best security practices, such as using a hardware wallet or multi-sig.&lt;/p&gt;

&lt;p&gt;In this latest price surge, a lot of new folks come in, techie or otherwise, and are worried of using complex software, but using the easier-to-use ones (such as hardware wallets) feels like being dependent on a specific piece of software. It might feel like you‚Äôre losing control of your coins, contrary to the promise of cryptocurrencies.&lt;/p&gt;

&lt;p&gt;I hope this post showed you that you‚Äôre not actually strongly tied to it - you could always recover from it, given you that you backed up your private keys, or your seed, and required metadata (such as redeem scripts). You can do it yourself or the help of your friendly techier Bitcoiner friend.&lt;/p&gt;

&lt;p&gt;There are, of course, other recovery cases which I didn‚Äôt cover - such as wallets and coins that don‚Äôt use these schemes and other types of coins which require special handling.&lt;/p&gt;

&lt;p&gt;To wrap it up, I‚Äôd want you to feel free to reach out to me (&lt;a href=&quot;mailto:kobigurk@gmail.com&quot;&gt;kobigurk@gmail.com&lt;/a&gt; or @kobigurk on Twitter) if you have any stuck coins you‚Äôd like help with, would like to consult about backing up enough data to be able to recover in the future or wondering about the deeper technical details of how all of this works.&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Having Bitcoins is nice and having them being stored securely is even nicer. Though, as often is the case, the additional security often invites complexity to frequent use of your money. There are great software and hardware solutions that make your money safer than ever. But it's not always easy to recover.</summary></entry><entry><title type="html">Phishing in the age of preview</title><link href="/2017/04/07/phising-preview.html" rel="alternate" type="text/html" title="Phishing in the age of preview" /><published>2017-04-07T00:00:00+03:00</published><updated>2017-04-07T00:00:00+03:00</updated><id>/2017/04/07/phising-preview</id><content type="html" xml:base="/2017/04/07/phising-preview.html">&lt;p&gt;Link previews are convenient. Implemented inside messaging platforms, they allow you to see the summary of a link a friend sent you without actually opening it, giving you the ability to decide whether it‚Äôs important or interesting enough to open it in a browser.&lt;/p&gt;

&lt;p&gt;Consider the following situation: Your WhatsApp account has been hacked. The hacker goes through your contacts list and message history, finding out who are your the people you‚Äôre conversing with the most. Then, the hacker prepares a malicious web-site - the web-site installs some malware that steals your bank account password once you go into it. The hacker even makes the web-site have a nice preview about a subject you‚Äôre discussing with your friend often, so your friend would think it‚Äôs a legitimate web-site. The friend, not knowing he‚Äôs talking with a hacker rather than his good friend, opens the link and gets infected!&lt;/p&gt;

&lt;p&gt;This may sound unrealistic - a messaging account getting hacked, but it happened to a colleague of mine in &lt;a href=&quot;http://qed-it.com&quot;&gt;QED-it&lt;/a&gt;. His Skype account got hacked and started distributing suspicious links to some of his contacts. Apparently, it was quite successful, as some of these contacts got hacked as well and sent him suspicious links back.&lt;/p&gt;

&lt;p&gt;So while it‚Äôs a multi-step phishing attack, once you get hold of a social media or messaging account, if you can construct believable links, it should be pretty easy to infect your contacts.&lt;/p&gt;

&lt;p&gt;#Wait, what?&lt;/p&gt;

&lt;p&gt;You must think - ‚Äúwell, this guy is crazy, it‚Äôs not that easy creating these links‚Äù. Is it really that easy to construct believable previews? Apparently yes! All you have to do is implement the &lt;a href=&quot;http://ogp.me/&quot;&gt;Open Graph Protocol&lt;/a&gt; on your web-page. This is a description of the Open Graph protocol, in their words:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Many of the messaging platforms support it - an incomplete list includes Facebook, WhatsApp and Telegram.&lt;/p&gt;

&lt;p&gt;In order to have a preview for your web-site, you just need to add this prefix to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html&lt;/code&gt; tag and these properties to your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; section:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;html prefix=&quot;og: http://ogp.me/ns#&quot;&amp;gt;
    &amp;lt;head&amp;gt; 
        &amp;lt;meta property=&quot;og:title&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:site_name&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:image&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:url&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta property=&quot;og:description&quot; content=&quot;&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;That‚Äôs it. The hacker can now insert whatever code he wants, even a redirect to another web-site.&lt;/p&gt;

&lt;p&gt;Another component which may be useful in order to mask the fact it‚Äôs a malicious URL would be a URL shortener such as &lt;a href=&quot;http://bit.ly&quot;&gt;bit.ly&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#Meh, that‚Äôs a bit of work
Well, then you can just use &lt;a href=&quot;http://roll.kobi.one/generator.html&quot;&gt;my tool&lt;/a&gt; to generate an auto-redirecting malicious URL shortened by bit.ly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/content/images/2017/04/Untitled.png&quot; alt=&quot;TPaaS&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, that‚Äôs really easy‚Ä¶&lt;/p&gt;

&lt;p&gt;This, &lt;a href=&quot;http://bit.ly/2oCoEeY&quot;&gt;http://bit.ly/2oCoEeY&lt;/a&gt; , is a link that has a preview exactly like a real BBC article, but actually rick-rolls you (advantage if you like Rick Astley music videos!). This is its preview as it‚Äôs rendered on Telegram:
&lt;img src=&quot;/content/images/2017/04/Untitled-1.png&quot; alt=&quot;TelegramExample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;#What can we do?
Good question. It‚Äôs always an interactive game - put a barrier, hackers get through and so on. But, in my feeling, there‚Äôs a lot of room for improvement regarding these previews.&lt;/p&gt;

&lt;p&gt;Facebook, for example, does a better job than the rest:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If a URL is given in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;og:url&lt;/code&gt; tag, that one is eventually used to retrieve the others.&lt;/li&gt;
  &lt;li&gt;If a URL is not given or invalid, then the actual URL is displayed under the post.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In Telegram and WhatsApp, this is not the case - you completely control the content that is shown to the user.&lt;/p&gt;

&lt;p&gt;So, to begin with, sites can show the actual URL being used to retrieve the tags.&lt;/p&gt;

&lt;p&gt;A different direction I‚Äôve been considering is similar to the HTTPS user experience existing in most major browsers:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;If the URL is not authenticated (HTTP), show a message that says ‚Äúthis preview is not secure‚Äù.&lt;/li&gt;
  &lt;li&gt;If the URL is from an HTTPS link, show the Common Name in the certificate.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These details alone would make the situation much better.&lt;/p&gt;

&lt;p&gt;#To summarize‚Ä¶
Link previews are nice and fun, but may also be used as a convenient tool to improve phishing campaigns considerably. I believe there are solutions to make it better and some platforms are realizing this and taking steps, but there‚Äôs more work to do.&lt;/p&gt;

&lt;p&gt;Hopefully we can combine the easiness and convenience with security!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Link previews are convenient. Implemented inside messaging platforms, they allow you to see the summary of a link a friend sent you without actually opening it, giving you the ability to decide whether it‚Äôs important or interesting enough to open it in a browser.</summary></entry><entry><title type="html">Mocking Ethereum contracts</title><link href="/2016/09/24/mocking-ethereum-contracts.html" rel="alternate" type="text/html" title="Mocking Ethereum contracts" /><published>2016-09-24T00:00:00+03:00</published><updated>2016-09-24T00:00:00+03:00</updated><id>/2016/09/24/mocking-ethereum-contracts</id><content type="html" xml:base="/2016/09/24/mocking-ethereum-contracts.html">&lt;p&gt;Testing frameworks have become important for development processes. They allow us to instrument our code and make sure it handles different cases. Mocking frameworks make it even better - if you have dependencies on external factors, you can make your code believe those dependencies act in a specified way so you can check your code knows how to deal with the different responses. Additionally, as Alex and Roman mentioned in a chat we had, mocks can help you develop when you don‚Äôt have the dependency ready, i.e. when someone else develops it and haven‚Äôt finished.&lt;/p&gt;

&lt;p&gt;For node.js, for example, we have Mocha as a testing framework a Sinon.JS as a mocking framework. This is a code example that shows the usage of these two together:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assert = require('assert');
var sinon = require('sinon');
                                                                                                                                                                                                                                                                                                                                                                           
it(&quot;returns the return value from the original function&quot;, function () {
  var myAPI = {
    method: function () {
      return 5;
    }
  };
  var mock = sinon.mock(myAPI);
  mock.expects(&quot;method&quot;).returns(42);

  var result = myAPI.method();
  assert.equal(result, 42);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this example, you take a function, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myAPI.method&lt;/code&gt;, that usually returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;, and make it return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;42&lt;/code&gt;. This is useful when you want to see how your code behaves when, for example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;result&lt;/code&gt; is larger than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;30&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A more complex example would be:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assert = require('assert');
var sinon = require('sinon');
                                                                                                                                                                                                                                                                                                                                                                           
function once(fn) {
  var returnValue, called = false;
  return function () {
      if (!called) {
        called = true;
          returnValue = fn.apply(this, arguments);
      }
      return returnValue;
  };
}

it(&quot;returns the return value from the original function&quot;, function () {
  var myAPI = { 
    method: function () {
      return 5;
    } 
  };
  var mock = sinon.mock(myAPI);
  mock.expects(&quot;method&quot;).returns(42);

  var proxy = once(myAPI.method);

  assert.equals(proxy(), 42);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this example, we don‚Äôt call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;myAPI.method&lt;/code&gt; directly. Instead, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;once&lt;/code&gt; calls it. So although we didn‚Äôt call it directly, the method was still mocked and returned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;42&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;testing-in-ethereum&quot;&gt;Testing in Ethereum&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://live.ether.camp/&quot; target=&quot;_blank&quot;&gt;Ether.camp&lt;/a&gt; has been working on a pretty cool testing framework, utilizing the sandbox they developed for the excellent IDE, &lt;strong&gt;Ethereum Studio&lt;/strong&gt;. You can see examples of it &lt;a href=&quot;https://github.com/ether-camp/ethereum-testing-reference&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let‚Äôs look at a specific example. Let‚Äôs say you wrote this simple math performing contract, &lt;strong&gt;Math.sol&lt;/strong&gt;, using Solidity:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Math&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	    
    &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	    
    &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	    
    &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	    
    &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A simple test case would be:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assert = require('assert');

var Workbench = require('ethereum-sandbox-workbench');
var workbench = new Workbench({
  defaults: {
    from: '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826'
  }
});
var sandbox = workbench.sandbox;

workbench.startTesting('Math', function(contracts) {
  it('sum-test', function() {
    return contracts.Math.new()
    .then(function(contract) {
      return contract.sum(2,2);
    })
    .then(function (txHash) {
      return workbench.waitForSandboxReceipt(txHash);
    })
    .then(function (receipt) {
      var result = sandbox.web3.toBigNumber(receipt.returnValue).toNumber();
      assert.equal(result, 4);
      assert.notEqual(result, 5);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This test case does the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Start a configured sandbox environment to which contracts can be deployed.&lt;/li&gt;
  &lt;li&gt;Deploys the &lt;strong&gt;Math&lt;/strong&gt; contract to the sandbox.&lt;/li&gt;
  &lt;li&gt;Checks that addition actually works correctly in Ethereum. If you run this test case with Mocha, you‚Äôll be sure to see it does!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You probably noticed that after calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;startTesting&lt;/code&gt; we have access to the compiled contracts with an easy-to-use, promise based, interface. This is thanks to &lt;a href=&quot;https://github.com/ConsenSys/ether-pudding&quot; target=&quot;_blank&quot;&gt;Ether Pudding&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;mocking-in-ethereum&quot;&gt;Mocking in Ethereum&lt;/h1&gt;
&lt;p&gt;But what about mocking? When you‚Äôre testing Ethereum contracts, it‚Äôs more than a matter of modifying javascript functions. Ethereum contracts are pieces of code living on the Ethereum blockchain, accessible by sending transactions or calling their address.&lt;/p&gt;

&lt;p&gt;For example, let‚Äôs look at the following contract:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;contract GoldPrice {function GoldPrice(); function price() constant returns(uint256 ); function notifyCallback(); function getPriceWithParameter(uint input) returns(uint);}

contract GoldPriceChecker {
  function GoldPriceChecker(address goldPriceContractAddress) {
    goldPriceContract = goldPriceContractAddress;
  }

  function getGoldPriceHappinessMeter() returns (uint) {
    uint feedPrice = GoldPrice(goldPriceContract).price();
    if (feedPrice &amp;gt; 200) {
      return 1;
    } else {
      return 2;
    }
  }

  address goldPriceContract;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This contract checks the price of gold and returns a ‚Äúhappiness meter‚Äù depending on the price. It depends on a &lt;strong&gt;GoldPrice&lt;/strong&gt; contract, of which‚Äôs address is provided in our contract‚Äôs constructor. The interface of the &lt;strong&gt;GoldPrice&lt;/strong&gt; contract is:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;contract GoldPrice {
  function GoldPrice(); 
  function price() constant returns(uint256); 
  function notifyCallback(); 
  function getPriceWithParameter(uint input) returns(uint);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means that if we were to mock an Ethereum contract, we would want an entity living on the blockchain that will respond instead of the mocked contract, but still adhering to the same interface.&lt;/p&gt;

&lt;h1 id=&quot;enter-proxy-contract&quot;&gt;Enter proxy contract&lt;/h1&gt;
&lt;p&gt;A solution for this may be fulfilled a contract providing the following features:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Can be accessed with the same interface of the mocked contract.&lt;/li&gt;
  &lt;li&gt;Can be configured with desired responses to calls to mocked functions.&lt;/li&gt;
  &lt;li&gt;Can be configured with desired follow-up transactions to mocked functions.&lt;/li&gt;
  &lt;li&gt;Can notify when a mocked contract function was called.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In order to understand how to create such a contract, we need to understand how transactions and calls in Ethereum work.&lt;/p&gt;

&lt;h1 id=&quot;ethereum-contract-abi&quot;&gt;Ethereum Contract ABI&lt;/h1&gt;
&lt;p&gt;Let‚Äôs say we want to call the Solidity function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getPriceWithParameter&lt;/code&gt; with the parameter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;. According to the &lt;a href=&quot;https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI&quot; target=&quot;_blank&quot;&gt;Ethereum Contract ABI&lt;/a&gt;, we first calculate the Method ID: first 4 bytes of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sha3(&quot;getPriceWithParameter(uint256)&quot;)&lt;/code&gt;. In our case, it would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x60360e31&lt;/code&gt;. Then, we encode the parameters. In our case, it would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x0000000000000000000000000000000000000000000000000000000000000005&lt;/code&gt;.  Then, we concatenate them.&lt;/p&gt;

&lt;p&gt;Ether Pudding and web3 provide us with easy-to-use javascript wrapper to do all of this automatically. That means that if we have an Ether Pudding instance of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goldPrice&lt;/code&gt; which was deployed at address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xabcdefababcdefababcdefababcdefababcdefab&lt;/code&gt;, then calling the following:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;goldPrice.getPriceWithParaemeter(5, {
  from: '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826'
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web3.eth.call({
  from: '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826',
  to: '0xabcdefababcdefababcdefababcdefababcdefab',
  data: '0x60360e310000000000000000000000000000000000000000000000000000000000000005'
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the Solidity code of the contract iself, it‚Äôs possible to access the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; using the globally available &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.data&lt;/code&gt;, which is of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt;, and the method ID using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.sig&lt;/code&gt;, which is of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes4&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;proxy-contract&quot;&gt;Proxy contract&lt;/h1&gt;
&lt;p&gt;Without further ado, I present you the Proxy contract:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;contract Proxy {

  bool _traceFunctionCalls = false;
  event Trace(address caller, bytes data, uint value);

  function Proxy(bool traceFunctionCalls) {
    _traceFunctionCalls = traceFunctionCalls;
  }

  function setMock(bytes4 method, uint8 operationType, address target, bytes data) {
    operations[method] = Operation(operationType, target, data);
  }

  function setMockWithArgs(bytes methodWithData, uint8 operationType, address target, bytes data) {
    operationsWithArgs[methodWithData] = Operation(operationType, target, data);
  }

  function() {
    if (_traceFunctionCalls) {
      Trace(msg.sender, msg.data, msg.value);
    }
    Operation memory operation = operationsWithArgs[msg.data];
    uint8 operationType = operation.operationType;
    if (operationType == 0) {
      operation = operations[msg.sig];
      operationType = operation.operationType;
      if (operationType == 0) {
        throw;
      }
    } 

    if (operationType == 1) {
      address target = operation.target;
      target.call(operation.data);
    } else if (operationType == 2) {
      bytes memory data = operation.data;
      assembly {
        return(add(data, 32), mload(data))
      }
    } else {
      throw;
    }
  }

  struct Operation {
    uint8 operationType;
    address target;
    bytes data;
  }

  mapping (bytes4 =&amp;gt; Operation) operations;
  mapping (bytes =&amp;gt; Operation) operationsWithArgs;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As can be seen in the contract code, it has three functions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMock&lt;/code&gt; that allows you to set return values or a follow-up transaction when invoking the contract with the specified method ID (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.sig&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMockWithArgs&lt;/code&gt; that allows you to set return values or a follow-up transaction when invoking the contract with the specified method ID + arguments (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.data&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Fallback function (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;function () {}&lt;/code&gt;) that is called when invoked with neither of the previous ones. The fallback function checks if a mock has been configured and acts accordingly.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The way the proxy contract works for mocking is by pointing the Ether Pudding interface of the mocked contract, i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; at the address of a deployed proxy contract. Then, when functions are invoked on that instance, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.data&lt;/code&gt; of the resulting call will be an attempt to invoke the function of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; contract on the proxy contract itself.&lt;/p&gt;

&lt;p&gt;Let‚Äôs look at a concrete example. Let‚Äôs assume we‚Äôve deployed the proxy contract. Then, we invoked &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMock&lt;/code&gt; with the following arguments: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setMock(0x60360e31, 2, 0x0, 0x0000000000000000000000000000000000000000000000000000000000000005)&lt;/code&gt;. In other words, we‚Äôve configured the proxy contract to return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; when called with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg.sig&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x6036e31&lt;/code&gt;. By pointing the Ether Pudding interface of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; at the deployed proxy contract, the resulting object being &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goldPrice&lt;/code&gt;, this is equivalent to calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goldPrice.getPriceWithParameter&lt;/code&gt; with any parameter.&lt;/p&gt;

&lt;p&gt;Before I‚Äôll show you how to use it in the mocking framework, I want to point you to the following part in the proxy contract:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bytes memory data = operation.data;
assembly {
  return(add(data, 32), mload(data))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There‚Äôs a bit of inline assembly here. This is required because we want to be able to return any type of value from the contract. That means that we don‚Äôt want to limit ourselves to being able to make only functions that return, i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint256&lt;/code&gt;. By using inline assembly and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; opcode, we are able force the contract to return with the bytes saved when the mock was configured.&lt;/p&gt;

&lt;p&gt;To understand how this works, we should look at how a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; variable is stored in memory - first the number of bytes in the array padded to 32 bytes and then the data itself.&lt;/p&gt;

&lt;p&gt;The quoted code segment does the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Copies &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;operation.data&lt;/code&gt; from storage to memory, by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memory&lt;/code&gt; keyword. This is needed, because the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; opcode returns from memory.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mload&lt;/code&gt; loads the first 32 bytes of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; variables. This would be the length of the array.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add(data, 32)&lt;/code&gt; is the address of the actual data in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bytes&lt;/code&gt; array.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return(p,s)&lt;/code&gt; itself terminates the contract execution and returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; bytes of data starting  in memory address &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To learn more about in-line assembly, check out the &lt;a href=&quot;https://solidity.readthedocs.io/en/latest/control-structures.html#inline-assembly&quot; target=&quot;_blank&quot;&gt;Solidity documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;mocking-framework&quot;&gt;Mocking framework&lt;/h1&gt;
&lt;p&gt;To make life easy, we added the mocking framework to the &lt;a href=&quot;https://github.com/ether-camp/ethereum-sandbox-workbench&quot; target=&quot;_blank&quot;&gt;ethereum-sandbox-workbench&lt;/a&gt;. This is an example of working with it:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var assert = require('assert');
var Workbench = require('ethereum-sandbox-workbench');

var fromAddress = '0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826';
var workbench = new Workbench({
  defaults: {
    from: fromAddress
  }
});

var sandbox = workbench.sandbox;

workbench.startTesting(['GoldPrice', 'GoldPriceChecker'], function(contracts) {
  var goldPrice;
  var mockContract;
  var goldPriceChecker;

  it('tests-deploy', function() {
    return contracts.GoldPrice.new()
    .then(function(contract) {
      if (contract.address) {
        goldPrice = contract;
      } else {
        throw new Error('No address for deployed contract');
      }
    });
  });

  it('tests-deploy-proxy', function() {
    return contracts.GoldPrice.newMock({
      traceFunctionCalls: true
    })
    .then(function(contract) {
      mockContract = contract;
      return mockContract.price.mockCallReturnValue(299);
    })
    .then(function(receipt) {
      return mockContract.price.call();
    })
    .then(function(value) {
      assert(value.equals(299));
    });
  });

  it('tests-deploy-checker', function() {
    return contracts.GoldPriceChecker.new(mockContract.address)
    .then(function(contract) {
      goldPriceChecker = contract;
      return goldPriceChecker.getGoldPriceHappinessMeter.call();
    })
    .then(function(value) {
      assert.equal(value.toString(), '1');
      return mockContract.price.mockCallReturnValue(5);
    })
    .then(function(receipt) {
      return goldPriceChecker.getGoldPriceHappinessMeter.call();
    })
    .then(function(value) {
      assert.equal(value.toString(), '2');
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let‚Äôs recap what we see here:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;To deploy a proxy contract but have the interface of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; contract, we deploy using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;newMock&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To set-up a new mock for a call return value, we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mockCallReturnValue&lt;/code&gt; on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;price&lt;/code&gt; function.&lt;/li&gt;
  &lt;li&gt;Then the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goldPriceChecker&lt;/code&gt; which calls the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GoldPrice&lt;/code&gt; contract in its code sees the mocked value.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Similarly, you can mock a transaction response using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mockTransactionForward&lt;/code&gt; and trace function calls (making sure the functions were called in a specific transaction) using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wasCalled&lt;/code&gt; on the mocked function. To see examples of those, check out the &lt;a href=&quot;https://raw.githubusercontent.com/ether-camp/ethereum-testing-reference/master/test/mock/mock-test.js&quot; target=&quot;_blank&quot;&gt;test case&lt;/a&gt;!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">Testing frameworks have become important for development processes. They allow us to instrument our code and make sure it handles different cases. Mocking frameworks make it even better - if you have dependencies on external factors, you can make your code believe those dependencies act in a specified way so you can check your code knows how to deal with the different responses. Additionally, as Alex and Roman mentioned in a chat we had, mocks can help you develop when you don‚Äôt have the dependency ready, i.e. when someone else develops it and haven‚Äôt finished.</summary></entry><entry><title type="html">Additive Homomorphic Encryption on Ethereum</title><link href="/2016/04/10/additive-homomorphic-encryption-on-ethereum.html" rel="alternate" type="text/html" title="Additive Homomorphic Encryption on Ethereum" /><published>2016-04-10T00:00:00+03:00</published><updated>2016-04-10T00:00:00+03:00</updated><id>/2016/04/10/additive-homomorphic-encryption-on-ethereum</id><content type="html" xml:base="/2016/04/10/additive-homomorphic-encryption-on-ethereum.html">&lt;p&gt;A few months ago, the narrative in the cryptocurrency world changed from bitcoin to blockchain. Suddenly, bitcoin is old news and private blockchains are here to change the world. Apparently, blockchain is turning the financial world upside down.&lt;/p&gt;

&lt;p&gt;OK, let‚Äôs be serious - private blockchains are in the exploration phase. Financial institutions, insurance firms and many others are finding out how they can use the technology, or at least some of its concepts. One way to look at them is as a specialized database for specific use-cases. Projects like &lt;a href=&quot;https://www.hyperledger.org/&quot; target=&quot;_blank&quot;&gt;HyperLedger&lt;/a&gt; and &lt;a href=&quot;http://r3cev.com/blog/2016/4/4/introducing-r3-corda-a-distributed-ledger-designed-for-financial-services&quot; target=&quot;_blank&quot;&gt;Corda&lt;/a&gt; build infrastructures that will power some use-cases.&lt;/p&gt;

&lt;p&gt;But today I‚Äôd like to discuss something a bit different. For quite some time, I‚Äôve been interested in privacy on the blockchain. How can we add some privacy properties to public transactions while still gaining benefit from the underlying blockchain (such as finality, limited auditing, etc)? There are a few interesting ideas, some of them are explored in Vitalik‚Äôs blog post about &lt;a href=&quot;https://blog.ethereum.org/2016/01/15/privacy-on-the-blockchain/&quot; target=&quot;_blank&quot;&gt;Privacy on the Blockchain&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;#So, what can we do?
One approach which I wanted to explore is homomorphic encryption. From &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphic_encryption&quot; target=&quot;_blank&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Homomorphic encryption is a form of encryption that allows computations to be carried out on ciphertext, thus generating an encrypted result which, when decrypted, matches the result of operations performed on the plaintext.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example, assuming \(ENC\) and \(DEC\) are our encryption and decryption functions respectively, we can have:&lt;/p&gt;

\[x\_1=3, x\_2=4 \\\\ 
c\_1 = ENC(x\_1), c\_2 = ENC(x\_2) \\\\
c\_3 = F(c\_1, c\_2) \\\\
 \text{ such that} \\\\
x\_3 = DEC(c\_3) = x\_1 + x\_2\]

&lt;p&gt;By performing an operation on the encrypted \(x_1, x_2\) we got their sum.&lt;/p&gt;

&lt;p&gt;The ‚Äúholy grail‚Äù of homomorphic encryption is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphic_encryption#Fully_homomorphic_encryption&quot; target=&quot;_blank&quot;&gt;Fully Homomorphic Encryption&lt;/a&gt;, with which you can get results of arbitrary computations on encrypted data, not just their sum or product. One cryptosystem which provides you with &lt;em&gt;additive&lt;/em&gt; homomorphic encryption is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Paillier_cryptosystem&quot; target=&quot;_blank&quot;&gt;Paillier Cryptosystem&lt;/a&gt;. Additive here means that you can get the sum of two encrypted numbers.&lt;/p&gt;

&lt;p&gt;The Paillier Cryptosystem is an asymmetric encryption scheme, meaning that you encrypt with your public key and decrypt with your private key. Leaving the key generation process aside, the parameters we need to use the cryptosystem are:
\(\\text{public key} = (n, g) \\\\
\\text{private key} = (\lambda, \mu)\)
The specific meaning of the parameters is not needed for what I want to show, and they‚Äôre all the result of the key generation process.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Encryption process&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take \(m\), the number you want to encrypt. \(m\) is a member of \(\mathbb{Z}_n\).&lt;/li&gt;
  &lt;li&gt;Generate a random number \(r\).&lt;/li&gt;
  &lt;li&gt;The encrypted number will be \(c = g^m \cdot r^n \mod n^2\).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Decryption process&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take \(c\), the encrypted number, which is in \(\mathbb{Z}^*_{n^2}\).&lt;/li&gt;
  &lt;li&gt;The decrypted number will be \(m = \frac{(c^{\lambda} \mod n^2) - 1}{n} \cdot \mu \mod n\).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What we‚Äôre interested in now is the homomorphic addition property:
\(DEC(ENC(m\_1) \cdot ENC(m\_2)) = m\_1 + m\_2\)&lt;/p&gt;

&lt;p&gt;#Homomorphic Encryption in Practice
So what does that property give us? Let‚Äôs look at a specific use case. Let‚Äôs assume we have an Ethereum smart contract that manages the expenses of employees:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Every day, employees submit their expenses to the contract. They don‚Äôt wan the other employees to know their expenses, so they encrypt it and send it to the contract.&lt;/li&gt;
  &lt;li&gt;The contract adds the encrypted expense to the current total expenses amount.&lt;/li&gt;
  &lt;li&gt;At the end of every month, the company wants to know the total expenses amount, but doesn‚Äôt want anyone else to know it. They take the encrypted total expenses amount from the contract and decrypt it locally.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This would be a contract with my pre-generated parameters and an initial encrypted total expenses amount of 3:&lt;/p&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;contract&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paillierBalance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                
    &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2a6a2efecccf5f09e883b87528104e505dedb63fee8de93ccc059116bf32ae5f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xb033814c46b1c673d80ad171adbcf4bc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;nx&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xb033814c46b1c673d80ad171adbcf4bb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paillierBalance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                                      
        &lt;span class=&quot;nx&quot;&gt;controller&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquaredTemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nInner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;assembly&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nInner&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;nSquaredTemp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;nSquared&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquaredTemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                                 
    &lt;span class=&quot;nx&quot;&gt;modifier&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onlyController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
        &lt;span class=&quot;nx&quot;&gt;_&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;homomorphicAdd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;onlyController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalanceInner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              
        &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquaredInner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              
        &lt;span class=&quot;nx&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalanceTemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                                          
        &lt;span class=&quot;nx&quot;&gt;assembly&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_encryptedBalance&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalanceInner&lt;/span&gt;                  
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_encryptedChange&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedChange&lt;/span&gt;             
            &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_nSquared&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;nSquaredInner&lt;/span&gt;                  
            &lt;span class=&quot;nx&quot;&gt;encryptedBalanceTemp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mulmod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_encryptedBalance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;_encryptedChange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_nSquared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;encryptedBalance&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;encryptedBalanceTemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                            
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The encryption and decryption would be client side, using a &lt;a href=&quot;https://github.com/kobigurk/paillier&quot; target=&quot;_blank&quot;&gt;python paillier library&lt;/a&gt;. That means that the company first encrypts the initial balance, and whenever the employees want to report the expense, they use the &lt;strong&gt;homomorphicAdd&lt;/strong&gt; function. This function uses the homomorphic addition property to store the result of the sum of the previous balance and the new expense.&lt;/p&gt;

&lt;p&gt;In this manner, the contract has only one storage variable for the balance while employees can report an unlimited number of expenses.&lt;/p&gt;

&lt;p&gt;#Conclusion
To summarize, this shows a method with which we can preserve privacy while still have some auditing properties. In this example, people can know that they can trust that the final encrypted balance represents the sum of all of the expenses reliably.&lt;/p&gt;

&lt;p&gt;What kind of businesses would use methods like this? Time will tell. This is the moment that companies can be creative and find out new ways to architect their systems to work in a more transparent and efficient world.&lt;/p&gt;

&lt;p&gt;All in all, I feel there is a great potential in using this kind of methods and I would love to discuss ideas. Feel free to &lt;a href=&quot;/contact.html&quot;&gt;contact me&lt;/a&gt;!&lt;/p&gt;</content><author><name>Kobi</name></author><summary type="html">A few months ago, the narrative in the cryptocurrency world changed from bitcoin to blockchain. Suddenly, bitcoin is old news and private blockchains are here to change the world. Apparently, blockchain is turning the financial world upside down.</summary></entry></feed>